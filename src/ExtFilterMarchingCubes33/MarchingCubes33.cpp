/*
 * Copyright (c) 2014-2022 The Voxie Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <VoxieClient/ClaimedOperation.hpp>
#include <VoxieClient/DBusClient.hpp>
#include <VoxieClient/Exception.hpp>
#include <VoxieClient/Exceptions.hpp>
#include <VoxieClient/MappedBuffer.hpp>
#include <VoxieClient/QtUtil.hpp>
#include <VoxieClient/RefCountHolder.hpp>

#include <ExtFilterMarchingCubes33/MarchingCubes33.hpp>

#include <QtCore/QCommandLineParser>
#include <QtCore/QCoreApplication>
#include <QtCore/QDebug>
#include <QtCore/QString>

#include <QDebug>
#include <QtDBus/QDBusConnection>
#include <QtDBus/QDBusConnectionInterface>
#include <QtDBus/QDBusError>
#include <QtDBus/QDBusPendingReply>

#include <QtCore/QPointer>

#include "cmath"

#include <array>

/**
 *  The Marching Cubes algorithm is bassed on the paper "MARCHING CUBES: A HIGH
 * RESOLUTION 3D SURFACE CONSTRUCTION ALGORITHM" by W.E. Lorensen et al. with
 * the voxel layout being the same as in the paper with 2 differences:
 * - edges 11 and 12 of the paper are swapped
 * - all indices start at 0 instead of 1 like in the paper
 * - vertice 12 lies in the middle of the voxel
 *  Subcase layout and identification is based on the paper "Marching Cubes 33:
 * Construction of Topological Correct Isosurfaces" by E.V. Chernyaev with
 * several improvements made by L. Custodio et al. in the paper "Practical
 * considerations on Marching Cubes 33 topological correctness".
 *
 *
 * Corners
 *    7----------6
 *   /|         /|
 *  / |        / |
 * 3----------2  |
 * |  |       |  |
 * |  4-------|--5
 * | /        | /
 * |/         |/
 * 0----------1
 *
 * Edges
 *    -----6------
 *   /|         /|
 * 11 |       10 |
 * |----2-----|  5
 * |  7       |  |
 * 3  |----4--|--|
 * | 8        1 9
 * |/         |/
 * -----0------
 *
 *
 * Triangle Orientation
 *
 *     1            2
 *    / \          / \
 *   /   \        /   \
 *  /     \      /     \
 * 0-------2    0-------1
 * Frontside    Backside
 */

using namespace vx;

struct TRIANGLELABEL {
  int inside;
  int outside;
};

struct GRIDCELL {
  // Index of the voxel in xyz direction
  size_t x, y, z;
  // 3D position of the voxels corners
  QVector3D pos[8];
  // Value of the voxels corners
  double val[8];
};

/*
 * connected  - true if to diagonally opposed corners are connected through the
 *              voxel interior.
 * a, b, c    - Coefficients of: a*x^2 + b*x + c
 */
struct AMBIGUITYRESOLVERETURN {
  bool connected = false;
  float a, b, c;
};

QVector<QVector3D>* vertices = new QVector<QVector3D>;
QVector<MarchingCubes::TRIANGLE>* triangles =
    new QVector<MarchingCubes::TRIANGLE>;

// TODO: Should this be formatted with clang-format?
// clang-format off

/*
 * A table containing the case a specific configuration of corners create.
 * There are 15 cases, negativ numbers show that the inverse of the actual
 * definition is present. Negative 0 is only used for ease of understanding.
 */
static const int caseTable[256] = {
   0,  1,  1,  2,  1,  3,  2,  5,  1,  2, // 0
   3,  5,  2,  5,  5,  8,  1,  2,  3,  5,
   4,  6,  6, 11,  3,  5,  7,  9,  6, 14,
  12, -5,  1,  3,  2,  5,  3,  7,  5,  9,
   4,  6,  6, 14,  6, 12, 11, -5,  2,  5,

   5,  8,  6, 12, 14, -5,  6, 11, 12, -5, // 50
  10, -6, -6, -2,  1,  4,  3,  6,  2,  6,
   5, 14,  3,  6,  7, 12,  5, 11,  9, -5,
   3,  6,  7, 12,  6, 10, 12, -6,  7, 12,
  13, -7, 12, -6, -7, -3,  2,  6,  5, 11,

   5, 12,  8, -5,  6, 10, 12, -6, 14, -6, // 100
  -5, -2,  5, 14,  9, -5, 11, -6, -5, -2,
  12, -6, -7, -3, -6, -4, -3, -1,  1,  3,
   4,  6,  3,  7,  6, 12,  2,  5,  6, 11,
   5,  9, 14, -5,  2,  5,  6, 14,  6, 12,

  10, -6,  5,  8, 12, -5, 11, -5, -6, -2, // 150
   3,  7,  6, 12,  7, 13, 12, -7,  6, 12,
  10, -6, 12, -7, -6, -3,  5,  9, 11, -5,
  12, -7, -6, -3, 14, -5, -6, -2, -6, -3,
  -4, -1,  2,  6,  6, 10,  5, 12, 11, -6,

   5, 14, 12, -6,  8, -5, -5, -2,  5, 11, // 200
  12, -6, 14, -6, -6, -4,  9, -5, -7, -3,
  -5, -2, -3, -1,  5, 12, 14, -6,  9, -7,
  -5, -3, 11, -6, -6, -4, -5, -3, -2, -1,
   8, -5, -5, -2, -5, -3, -2, -1, -5, -2,

  -3, -1, -2, -1, -1, -0
};

/*
 * Contains 12-bit bit masks where each bit represents a vertex location:
 * bit = 1 -> vertex, bit = 0 -> no vertex
 * The entries correlate one to one with those of the case table.
 */
static const int edgeTable[256] = {
  0x0,   0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905,
  0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00, 0x190, 0x99,  0x393, 0x29a,
  0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93,
  0xf99, 0xe90, 0x230, 0x339, 0x33,  0x13a, 0x636, 0x73f, 0x435, 0x53c,
  0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, 0x3a0, 0x2a9,

  0x1a3, 0xaa,  0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6,
  0xfaa, 0xea3, 0xda9, 0xca0, 0x460, 0x569, 0x663, 0x76a, 0x66,  0x16f,
  0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
  0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff,  0x3f5, 0x2fc, 0xdfc, 0xcf5,
  0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0, 0x650, 0x759, 0x453, 0x55a,

  0x256, 0x35f, 0x55,  0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53,
  0x859, 0x950, 0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc,
  0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0, 0x8c0, 0x9c9,
  0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0xcc,  0x1c5, 0x2cf, 0x3c6,
  0x4ca, 0x5c3, 0x6c9, 0x7c0, 0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f,

  0xf55, 0xe5c, 0x15c, 0x55,  0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
  0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5,
  0xff,  0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0, 0xb60, 0xa69, 0x963, 0x86a,
  0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x66,  0x76a, 0x663,
  0x569, 0x460, 0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,

  0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa,  0x1a3, 0x2a9, 0x3a0, 0xd30, 0xc39,
  0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636,
  0x13a, 0x33,  0x339, 0x230, 0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f,
  0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99,  0x190,
  0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605,

  0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0
};

/*
 * Contains 13-bit bit masks where each bit represents a vertex location:
 * bit = 1 -> vertex, bit = 0 -> no vertex
 * The entries correlate one to one with those of triTableCase7.
 */
static const int edgeTableCase7[144] = {
  0xe6f, 0xe6f, 0xe6f, 0x1e6f, 0xe6f, 0x1e6f, 0x1e6f, 0xe6f, 0xe6f,
  0xe6f, 0xe6f, 0xe6f, 0x1e6f, 0xe6f, 0x1e6f, 0x1e6f, 0xe6f, 0xe6f,

  0xef6, 0xef6, 0xef6, 0x1ef6, 0xef6, 0x1ef6, 0x1ef6, 0xef6, 0xef6,
  0xef6, 0xef6, 0xef6, 0x1ef6, 0xef6, 0x1ef6, 0x1ef6, 0xef6, 0xef6,

  0xdfc, 0xdfc, 0xdfc, 0x1dfc, 0xdfc, 0x1dfc, 0x1dfc, 0xdfc, 0xdfc,
  0xdfc, 0xdfc, 0xdfc, 0x1dfc, 0xdfc, 0x1dfc, 0x1dfc, 0xdfc, 0xdfc,

  0xdcf, 0xdcf, 0xdcf, 0x1dcf, 0xdcf, 0x1dcf, 0x1dcf, 0xdcf, 0xdcf,
  0xdcf, 0xdcf, 0xdcf, 0x1dcf, 0xdcf, 0x1dcf, 0x1dcf, 0xdcf, 0xdcf,

  0x73f, 0x73f, 0x73f, 0x173f, 0x73f, 0x173f, 0x173f, 0x73f, 0x73f,
  0x73f, 0x73f, 0x73f, 0x173f, 0x73f, 0x173f, 0x173f, 0x73f, 0x73f,

  0x7f3, 0x7f3, 0x7f3, 0x17f3, 0x7f3, 0x17f3, 0x17f3, 0x7f3, 0x7f3,
  0x7f3, 0x7f3, 0x7f3, 0x17f3, 0x7f3, 0x17f3, 0x17f3, 0x7f3, 0x7f3,

  0xbf9, 0xbf9, 0xbf9, 0x1bf9, 0xbf9, 0x1bf9, 0x1bf9, 0xbf9, 0xbf9,
  0xbf9, 0xbf9, 0xbf9, 0x1bf9, 0xbf9, 0x1bf9, 0x1bf9, 0xbf9, 0xbf9,

  0xb9f, 0xb9f, 0xb9f, 0x1b9f, 0xb9f, 0x1b9f, 0x1b9f, 0xb9f, 0xb9f,
  0xb9f, 0xb9f, 0xb9f, 0x1b9f, 0xb9f, 0x1b9f, 0x1b9f, 0xb9f, 0xb9f,
};

/*
 * Contains 13-bit bit masks where each bit represents a vertex location:
 * bit = 1 -> vertex, bit = 0 -> no vertex
 * The entries correlate one to one with those of triTableCase10.
 */
static const int edgeTableCase10[24] = {
  0xff , 0xff , 0x10ff, 0x10ff,
  0xfaa, 0xfaa, 0x1faa, 0x1faa,
  0xf55, 0xf55, 0x1f55, 0x1f55,
  0xff , 0xff , 0x10ff, 0x10ff,
  0xfaa, 0xfaa, 0x1faa, 0x1faa,
  0xf55, 0xf55, 0x1f55, 0x1f55,
};

/*
 * Contains arrays indicating which vertices are connected to a triangle.
 * Vertices have indices from 0 to 11, three following entries create a
 * triangle. -1 marks the point after which no more trianlges are in the array.
 * The entries correlate one to one with those of caseTable.
*/
static const int triTable[256][16] = {
  {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 0,  8,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 0,  1,  9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 1,  8,  3,  9,  8,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 1,  2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 0,  8,  3,  1,  2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 9,  2, 10,  0,  2,  9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 2,  8,  3,  2, 10,  8, 10,  9,  8, -1, -1, -1, -1, -1, -1, -1},
  { 3, 11,  2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 0, 11,  2,  8, 11,  0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},

  { 1,  9,  0,  2,  3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 1, 11,  2,  1,  9, 11,  9,  8, 11, -1, -1, -1, -1, -1, -1, -1},
  { 3, 10,  1, 11, 10,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 0, 10,  1,  0,  8, 10,  8, 11, 10, -1, -1, -1, -1, -1, -1, -1},
  { 3,  9,  0,  3, 11,  9, 11, 10,  9, -1, -1, -1, -1, -1, -1, -1},
  { 9,  8, 10, 10,  8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 4,  7,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 4,  3,  0,  7,  3,  4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 0,  1,  9,  8,  4,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 4,  1,  9,  4,  7,  1,  7,  3,  1, -1, -1, -1, -1, -1, -1, -1},

  { 1,  2, 10,  8,  4,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 3,  4,  7,  3,  0,  4,  1,  2, 10, -1, -1, -1, -1, -1, -1, -1},
  { 9,  2, 10,  9,  0,  2,  8,  4,  7, -1, -1, -1, -1, -1, -1, -1},
  { 2, 10,  9,  2,  9,  7,  2,  7,  3,  7,  9,  4, -1, -1, -1, -1},
  { 8,  4,  7,  3, 11,  2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  {11,  4,  7, 11,  2,  4,  2,  0,  4, -1, -1, -1, -1, -1, -1, -1},
  { 9,  0,  1,  8,  4,  7,  2,  3, 11, -1, -1, -1, -1, -1, -1, -1},
  { 4,  7, 11,  9,  4, 11,  9, 11,  2,  9,  2,  1, -1, -1, -1, -1},
  { 3, 10,  1,  3, 11, 10,  7,  8,  4, -1, -1, -1, -1, -1, -1, -1},
  { 1, 11, 10,  1,  4, 11,  1,  0,  4,  7, 11,  4, -1, -1, -1, -1},

  { 4,  7,  8,  9,  0, 11,  9, 11, 10, 11,  0,  3, -1, -1, -1, -1},
  { 4,  7, 11,  4, 11,  9,  9, 11, 10, -1, -1, -1, -1, -1, -1, -1},
  { 9,  5,  4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 9,  5,  4,  0,  8,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 0,  5,  4,  1,  5,  0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 8,  5,  4,  8,  3,  5,  3,  1,  5, -1, -1, -1, -1, -1, -1, -1},
  { 1,  2, 10,  9,  5,  4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 3,  0,  8,  1,  2, 10,  4,  9,  5, -1, -1, -1, -1, -1, -1, -1},
  { 5,  2, 10,  5,  4,  2,  4,  0,  2, -1, -1, -1, -1, -1, -1, -1},
  { 2, 10,  5,  3,  2,  5,  3,  5,  4,  3,  4,  8, -1, -1, -1, -1},

  { 9,  5,  4,  2,  3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 0, 11,  2,  0,  8, 11,  4,  9,  5, -1, -1, -1, -1, -1, -1, -1},
  { 0,  5,  4,  0,  1,  5,  2,  3, 11, -1, -1, -1, -1, -1, -1, -1},
  { 2,  1,  5,  2,  5,  8,  2,  8, 11,  4,  8,  5, -1, -1, -1, -1},
  {10,  3, 11, 10,  1,  3,  9,  5,  4, -1, -1, -1, -1, -1, -1, -1},
  { 4,  9,  5,  0,  8,  1,  8, 10,  1,  8, 11, 10, -1, -1, -1, -1},
  { 5,  4,  0,  5,  0, 11,  5, 11, 10, 11,  0,  3, -1, -1, -1, -1},
  { 5,  4,  8,  5,  8, 10, 10,  8, 11, -1, -1, -1, -1, -1, -1, -1},
  { 9,  7,  8,  5,  7,  9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 9,  3,  0,  9,  5,  3,  5,  7,  3, -1, -1, -1, -1, -1, -1, -1},


  { 0,  7,  8,  0,  1,  7,  1,  5,  7, -1, -1, -1, -1, -1, -1, -1},
  { 1,  5,  3,  3,  5,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 9,  7,  8,  9,  5,  7, 10,  1,  2, -1, -1, -1, -1, -1, -1, -1},
  {10,  1,  2,  9,  5,  0,  5,  3,  0,  5,  7,  3, -1, -1, -1, -1},
  { 8,  0,  2,  8,  2,  5,  8,  5,  7, 10,  5,  2, -1, -1, -1, -1},
  { 2, 10,  5,  2,  5,  3,  3,  5,  7, -1, -1, -1, -1, -1, -1, -1},
  { 7,  9,  5,  7,  8,  9,  3, 11,  2, -1, -1, -1, -1, -1, -1, -1},
  { 9,  5,  7,  9,  7,  2,  9,  2,  0,  2,  7, 11, -1, -1, -1, -1},
  { 2,  3, 11,  0,  1,  8,  1,  7,  8,  1,  5,  7, -1, -1, -1, -1},
  {11,  2,  1, 11,  1,  7,  7,  1,  5, -1, -1, -1, -1, -1, -1, -1},

  { 9,  5,  8,  8,  5,  7, 10,  1,  3, 10,  3, 11, -1, -1, -1, -1},
  { 5,  7,  0,  5,  0,  9,  7, 11,  0,  1,  0, 10, 11, 10,  0, -1},
  {11, 10,  0, 11,  0,  3, 10,  5,  0,  8,  0,  7,  5,  7,  0, -1},
  {11, 10,  5,  7, 11,  5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  {10,  6,  5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 0,  8,  3,  5, 10,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 9,  0,  1,  5, 10,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 1,  8,  3,  1,  9,  8,  5, 10,  6, -1, -1, -1, -1, -1, -1, -1},
  { 1,  6,  5,  2,  6,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 1,  6,  5,  1,  2,  6,  3,  0,  8, -1, -1, -1, -1, -1, -1, -1},

  { 9,  6,  5,  9,  0,  6,  0,  2,  6, -1, -1, -1, -1, -1, -1, -1},
  { 5,  9,  8,  5,  8,  2,  5,  2,  6,  3,  2,  8, -1, -1, -1, -1},
  { 2,  3, 11, 10,  6,  5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  {11,  0,  8, 11,  2,  0, 10,  6,  5, -1, -1, -1, -1, -1, -1, -1},
  { 0,  1,  9,  2,  3, 11,  5, 10,  6, -1, -1, -1, -1, -1, -1, -1},
  { 5, 10,  6,  1,  9,  2,  9, 11,  2,  9,  8, 11, -1, -1, -1, -1},
  { 6,  3, 11,  6,  5,  3,  5,  1,  3, -1, -1, -1, -1, -1, -1, -1},
  { 0,  8, 11,  0, 11,  5,  0,  5,  1,  5, 11,  6, -1, -1, -1, -1},
  { 3, 11,  6,  0,  3,  6,  0,  6,  5,  0,  5,  9, -1, -1, -1, -1},
  { 6,  5,  9,  6,  9, 11, 11,  9,  8, -1, -1, -1, -1, -1, -1, -1},

  { 5, 10,  6,  4,  7,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 4,  3,  0,  4,  7,  3,  6,  5, 10, -1, -1, -1, -1, -1, -1, -1},
  { 1,  9,  0,  5, 10,  6,  8,  4,  7, -1, -1, -1, -1, -1, -1, -1},
  {10,  6,  5,  1,  9,  7,  1,  7,  3,  7,  9,  4, -1, -1, -1, -1},
  { 6,  1,  2,  6,  5,  1,  4,  7,  8, -1, -1, -1, -1, -1, -1, -1},
  { 1,  2,  5,  5,  2,  6,  3,  0,  4,  3,  4,  7, -1, -1, -1, -1},
  { 8,  4,  7,  9,  0,  5,  0,  6,  5,  0,  2,  6, -1, -1, -1, -1},
  { 7,  3,  9,  7,  9,  4,  3,  2,  9,  5,  9,  6,  2,  6,  9, -1},
  { 3, 11,  2,  7,  8,  4, 10,  6,  5, -1, -1, -1, -1, -1, -1, -1},
  { 5, 10,  6,  4,  7,  2,  4,  2,  0,  2,  7, 11, -1, -1, -1, -1},

  { 0,  1,  9,  4,  7,  8,  2,  3, 11,  5, 10,  6, -1, -1, -1, -1},
  { 9,  2,  1,  9, 11,  2,  9,  4, 11,  7, 11,  4,  5, 10,  6, -1},
  { 8,  4,  7,  3, 11,  5,  3,  5,  1,  5, 11,  6, -1, -1, -1, -1},
  { 5,  1, 11,  5, 11,  6,  1,  0, 11,  7, 11,  4,  0,  4, 11, -1},
  { 0,  5,  9,  0,  6,  5,  0,  3,  6, 11,  6,  3,  8,  4,  7, -1},
  { 6,  5,  9,  6,  9, 11,  4,  7,  9,  7, 11,  9, -1, -1, -1, -1},
  {10,  4,  9,  6,  4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 4, 10,  6,  4,  9, 10,  0,  8,  3, -1, -1, -1, -1, -1, -1, -1},
  {10,  0,  1, 10,  6,  0,  6,  4,  0, -1, -1, -1, -1, -1, -1, -1},
  { 8,  3,  1,  8,  1,  6,  8,  6,  4,  6,  1, 10, -1, -1, -1, -1},


  { 1,  4,  9,  1,  2,  4,  2,  6,  4, -1, -1, -1, -1, -1, -1, -1},
  { 3,  0,  8,  1,  2,  9,  2,  4,  9,  2,  6,  4, -1, -1, -1, -1},
  { 0,  2,  4,  4,  2,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 8,  3,  2,  8,  2,  4,  4,  2,  6, -1, -1, -1, -1, -1, -1, -1},
  {10,  4,  9, 10,  6,  4, 11,  2,  3, -1, -1, -1, -1, -1, -1, -1},
  { 0,  8,  2,  2,  8, 11,  4,  9, 10,  4, 10,  6, -1, -1, -1, -1},
  { 3, 11,  2,  0,  1,  6,  0,  6,  4,  6,  1, 10, -1, -1, -1, -1},
  { 6,  4,  1,  6,  1, 10,  4,  8,  1,  2,  1, 11,  8, 11,  1, -1},
  { 9,  6,  4,  9,  3,  6,  9,  1,  3, 11,  6,  3, -1, -1, -1, -1},
  { 8, 11,  1,  8,  1,  0, 11,  6,  1,  9,  1,  4,  6,  4,  1, -1},

  { 3, 11,  6,  3,  6,  0,  0,  6,  4, -1, -1, -1, -1, -1, -1, -1},
  { 6,  4,  8, 11,  6,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 7, 10,  6,  7,  8, 10,  8,  9, 10, -1, -1, -1, -1, -1, -1, -1},
  { 0,  7,  3,  0, 10,  7,  0,  9, 10,  6,  7, 10, -1, -1, -1, -1},
  {10,  6,  7,  1, 10,  7,  1,  7,  8,  1,  8,  0, -1, -1, -1, -1},
  {10,  6,  7, 10,  7,  1,  1,  7,  3, -1, -1, -1, -1, -1, -1, -1},
  { 1,  2,  6,  1,  6,  8,  1,  8,  9,  8,  6,  7, -1, -1, -1, -1},
  { 2,  6,  9,  2,  9,  1,  6,  7,  9,  0,  9,  3,  7,  3,  9, -1},
  { 7,  8,  0,  7,  0,  6,  6,  0,  2, -1, -1, -1, -1, -1, -1, -1},
  { 7,  3,  2,  6,  7,  2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},

  { 2,  3, 11, 10,  6,  8, 10,  8,  9,  8,  6,  7, -1, -1, -1, -1},
  { 2,  0,  7,  2,  7, 11,  0,  9,  7,  6,  7, 10,  9, 10,  7, -1},
  { 1,  8,  0,  1,  7,  8,  1, 10,  7,  6,  7, 10,  2,  3, 11, -1},
  {11,  2,  1, 11,  1,  7, 10,  6,  1,  6,  7,  1, -1, -1, -1, -1},
  { 8,  9,  6,  8,  6,  7,  9,  1,  6, 11,  6,  3,  1,  3,  6, -1},
  { 0,  9,  1, 11,  6,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 7,  8,  0,  7,  0,  6,  3, 11,  0, 11,  6,  0, -1, -1, -1, -1},
  { 7, 11,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 7,  6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 3,  0,  8, 11,  7,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},

  { 0,  1,  9, 11,  7,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 8,  1,  9,  8,  3,  1, 11,  7,  6, -1, -1, -1, -1, -1, -1, -1},
  {10,  1,  2,  6, 11,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 1,  2, 10,  3,  0,  8,  6, 11,  7, -1, -1, -1, -1, -1, -1, -1},
  { 2,  9,  0,  2, 10,  9,  6, 11,  7, -1, -1, -1, -1, -1, -1, -1},
  { 6, 11,  7,  2, 10,  3, 10,  8,  3, 10,  9,  8, -1, -1, -1, -1},
  { 7,  2,  3,  6,  2,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 7,  0,  8,  7,  6,  0,  6,  2,  0, -1, -1, -1, -1, -1, -1, -1},
  { 2,  7,  6,  2,  3,  7,  0,  1,  9, -1, -1, -1, -1, -1, -1, -1},
  { 1,  6,  2,  1,  8,  6,  1,  9,  8,  8,  7,  6, -1, -1, -1, -1},

  {10,  7,  6, 10,  1,  7,  1,  3,  7, -1, -1, -1, -1, -1, -1, -1},
  {10,  7,  6,  1,  7, 10,  1,  8,  7,  1,  0,  8, -1, -1, -1, -1},
  { 0,  3,  7,  0,  7, 10,  0, 10,  9,  6, 10,  7, -1, -1, -1, -1},
  { 7,  6, 10,  7, 10,  8,  8, 10,  9, -1, -1, -1, -1, -1, -1, -1},
  { 6,  8,  4, 11,  8,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 3,  6, 11,  3,  0,  6,  0,  4,  6, -1, -1, -1, -1, -1, -1, -1},
  { 8,  6, 11,  8,  4,  6,  9,  0,  1, -1, -1, -1, -1, -1, -1, -1},
  { 9,  4,  6,  9,  6,  3,  9,  3,  1, 11,  3,  6, -1, -1, -1, -1},
  { 6,  8,  4,  6, 11,  8,  2, 10,  1, -1, -1, -1, -1, -1, -1, -1},
  { 1,  2, 10,  3,  0, 11,  0,  6, 11,  0,  4,  6, -1, -1, -1, -1},


  { 4, 11,  8,  4,  6, 11,  0,  2,  9,  2, 10,  9, -1, -1, -1, -1},
  {10,  9,  3, 10,  3,  2,  9,  4,  3, 11,  3,  6,  4,  6,  3, -1},
  { 8,  2,  3,  8,  4,  2,  4,  6,  2, -1, -1, -1, -1, -1, -1, -1},
  { 0,  4,  2,  4,  6,  2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 1,  9,  0,  2,  3,  4,  2,  4,  6,  4,  3,  8, -1, -1, -1, -1},
  { 1,  9,  4,  1,  4,  2,  2,  4,  6, -1, -1, -1, -1, -1, -1, -1},
  { 8,  1,  3,  8,  6,  1,  8,  4,  6,  6, 10,  1, -1, -1, -1, -1},
  {10,  1,  0, 10,  0,  6,  6,  0,  4, -1, -1, -1, -1, -1, -1, -1},
  { 4,  6,  3,  4,  3,  8,  6, 10,  3,  0,  3,  9, 10,  9,  3, -1},
  {10,  9,  4,  6, 10,  4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},

  { 4,  9,  5,  7,  6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 0,  8,  3,  4,  9,  5, 11,  7,  6, -1, -1, -1, -1, -1, -1, -1},
  { 5,  0,  1,  5,  4,  0,  7,  6, 11, -1, -1, -1, -1, -1, -1, -1},
  {11,  7,  6,  8,  3,  4,  3,  5,  4,  3,  1,  5, -1, -1, -1, -1},
  { 9,  5,  4, 10,  1,  2,  7,  6, 11, -1, -1, -1, -1, -1, -1, -1},
  { 6, 11,  7,  1,  2, 10,  0,  8,  3,  4,  9,  5, -1, -1, -1, -1},
  { 7,  6, 11,  5,  4, 10,  4,  2, 10,  4,  0,  2, -1, -1, -1, -1},
  { 3,  4,  8,  3,  5,  4,  3,  2,  5, 10,  5,  2, 11,  7,  6, -1},
  { 7,  2,  3,  7,  6,  2,  5,  4,  9, -1, -1, -1, -1, -1, -1, -1},
  { 9,  5,  4,  0,  8,  6,  0,  6,  2,  6,  8,  7, -1, -1, -1, -1},

  { 3,  6,  2,  3,  7,  6,  1,  5,  0,  5,  4,  0, -1, -1, -1, -1},
  { 6,  2,  8,  6,  8,  7,  2,  1,  8,  4,  8,  5,  1,  5,  8, -1},
  { 9,  5,  4, 10,  1,  6,  1,  7,  6,  1,  3,  7, -1, -1, -1, -1},
  { 1,  6, 10,  1,  7,  6,  1,  0,  7,  8,  7,  0,  9,  5,  4, -1},
  { 4,  0, 10,  4, 10,  5,  0,  3, 10,  6, 10,  7,  3,  7, 10, -1},
  { 7,  6, 10,  7, 10,  8,  5,  4, 10,  4,  8, 10, -1, -1, -1, -1},
  { 6,  9,  5,  6, 11,  9, 11,  8,  9, -1, -1, -1, -1, -1, -1, -1},
  { 3,  6, 11,  0,  6,  3,  0,  5,  6,  0,  9,  5, -1, -1, -1, -1},
  { 0, 11,  8,  0,  5, 11,  0,  1,  5,  5,  6, 11, -1, -1, -1, -1},
  { 6, 11,  3,  6,  3,  5,  5,  3,  1, -1, -1, -1, -1, -1, -1, -1},

  { 1,  2, 10,  9,  5, 11,  9, 11,  8, 11,  5,  6, -1, -1, -1, -1},
  { 0, 11,  3,  0,  6, 11,  0,  9,  6,  5,  6,  9,  1,  2, 10, -1},
  {11,  8,  5, 11,  5,  6,  8,  0,  5, 10,  5,  2,  0,  2,  5, -1},
  { 6, 11,  3,  6,  3,  5,  2, 10,  3, 10,  5,  3, -1, -1, -1, -1},
  { 5,  8,  9,  5,  2,  8,  5,  6,  2,  3,  8,  2, -1, -1, -1, -1},
  { 9,  5,  6,  9,  6,  0,  0,  6,  2, -1, -1, -1, -1, -1, -1, -1},
  { 1,  5,  8,  1,  8,  0,  5,  6,  8,  3,  8,  2,  6,  2,  8, -1},
  { 1,  5,  6,  2,  1,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 1,  3,  6,  1,  6, 10,  3,  8,  6,  5,  6,  9,  8,  9,  6, -1},
  {10,  1,  0, 10,  0,  6,  9,  5,  0,  5,  6,  0, -1, -1, -1, -1},

  { 0,  3,  8,  5,  6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  {10,  5,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  {11,  5, 10,  7,  5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  {11,  5, 10, 11,  7,  5,  8,  3,  0, -1, -1, -1, -1, -1, -1, -1},
  { 5, 11,  7,  5, 10, 11,  1,  9,  0, -1, -1, -1, -1, -1, -1, -1},
  {10,  7,  5, 10, 11,  7,  9,  8,  1,  8,  3,  1, -1, -1, -1, -1},
  {11,  1,  2, 11,  7,  1,  7,  5,  1, -1, -1, -1, -1, -1, -1, -1},
  { 0,  8,  3,  1,  2,  7,  1,  7,  5,  7,  2, 11, -1, -1, -1, -1},
  { 9,  7,  5,  9,  2,  7,  9,  0,  2,  2, 11,  7, -1, -1, -1, -1},
  { 7,  5,  2,  7,  2, 11,  5,  9,  2,  3,  2,  8,  9,  8,  2, -1},


  { 2,  5, 10,  2,  3,  5,  3,  7,  5, -1, -1, -1, -1, -1, -1, -1},
  { 8,  2,  0,  8,  5,  2,  8,  7,  5, 10,  2,  5, -1, -1, -1, -1},
  { 9,  0,  1,  5, 10,  3,  5,  3,  7,  3, 10,  2, -1, -1, -1, -1},
  { 9,  8,  2,  9,  2,  1,  8,  7,  2, 10,  2,  5,  7,  5,  2, -1},
  { 1,  3,  5,  3,  7,  5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 0,  8,  7,  0,  7,  1,  1,  7,  5, -1, -1, -1, -1, -1, -1, -1},
  { 9,  0,  3,  9,  3,  5,  5,  3,  7, -1, -1, -1, -1, -1, -1, -1},
  { 9,  8,  7,  5,  9,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 5,  8,  4,  5, 10,  8, 10, 11,  8, -1, -1, -1, -1, -1, -1, -1},
  { 5,  0,  4,  5, 11,  0,  5, 10, 11, 11,  3,  0, -1, -1, -1, -1},

  { 0,  1,  9,  8,  4, 10,  8, 10, 11, 10,  4,  5, -1, -1, -1, -1},
  {10, 11,  4, 10,  4,  5, 11,  3,  4,  9,  4,  1,  3,  1,  4, -1},
  { 2,  5,  1,  2,  8,  5,  2, 11,  8,  4,  5,  8, -1, -1, -1, -1},
  { 0,  4, 11,  0, 11,  3,  4,  5, 11,  2, 11,  1,  5,  1, 11, -1},
  { 0,  2,  5,  0,  5,  9,  2, 11,  5,  4,  5,  8, 11,  8,  5, -1},
  { 9,  4,  5,  2, 11,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 2,  5, 10,  3,  5,  2,  3,  4,  5,  3,  8,  4, -1, -1, -1, -1},
  { 5, 10,  2,  5,  2,  4,  4,  2,  0, -1, -1, -1, -1, -1, -1, -1},
  { 3, 10,  2,  3,  5, 10,  3,  8,  5,  4,  5,  8,  0,  1,  9, -1},
  { 5, 10,  2,  5,  2,  4,  1,  9,  2,  9,  4,  2, -1, -1, -1, -1},

  { 8,  4,  5,  8,  5,  3,  3,  5,  1, -1, -1, -1, -1, -1, -1, -1},
  { 0,  4,  5,  1,  0,  5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 8,  4,  5,  8,  5,  3,  9,  0,  5,  0,  3,  5, -1, -1, -1, -1},
  { 9,  4,  5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 4, 11,  7,  4,  9, 11,  9, 10, 11, -1, -1, -1, -1, -1, -1, -1},
  { 0,  8,  3,  4,  9,  7,  9, 11,  7,  9, 10, 11, -1, -1, -1, -1},
  { 1, 10, 11,  1, 11,  4,  1,  4,  0,  7,  4, 11, -1, -1, -1, -1},
  { 3,  1,  4,  3,  4,  8,  1, 10,  4,  7,  4, 11, 10, 11,  4, -1},
  { 4, 11,  7,  9, 11,  4,  9,  2, 11,  9,  1,  2, -1, -1, -1, -1},
  { 9,  7,  4,  9, 11,  7,  9,  1, 11,  2, 11,  1,  0,  8,  3, -1},

  {11,  7,  4, 11,  4,  2,  2,  4,  0, -1, -1, -1, -1, -1, -1, -1},
  {11,  7,  4, 11,  4,  2,  8,  3,  4,  3,  2,  4, -1, -1, -1, -1},
  { 2,  9, 10,  2,  7,  9,  2,  3,  7,  7,  4,  9, -1, -1, -1, -1},
  { 9, 10,  7,  9,  7,  4, 10,  2,  7,  8,  7,  0,  2,  0,  7, -1},
  { 3,  7, 10,  3, 10,  2,  7,  4, 10,  1, 10,  0,  4,  0, 10, -1},
  { 1, 10,  2,  8,  7,  4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 4,  9,  1,  4,  1,  7,  7,  1,  3, -1, -1, -1, -1, -1, -1, -1},
  { 4,  9,  1,  4,  1,  7,  0,  8,  1,  8,  7,  1, -1, -1, -1, -1},
  { 4,  0,  3,  7,  4,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 4,  8,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},

  { 9, 10,  8, 10, 11,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 3,  0,  9,  3,  9, 11, 11,  9, 10, -1, -1, -1, -1, -1, -1, -1},
  { 0,  1, 10,  0, 10,  8,  8, 10, 11, -1, -1, -1, -1, -1, -1, -1},
  { 3,  1, 10, 11,  3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 1,  2, 11,  1, 11,  9,  9, 11,  8, -1, -1, -1, -1, -1, -1, -1},
  { 3,  0,  9,  3,  9, 11,  1,  2,  9,  2, 11,  9, -1, -1, -1, -1},
  { 0,  2, 11,  8,  0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 3,  2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 2,  3,  8,  2,  8, 10, 10,  8,  9, -1, -1, -1, -1, -1, -1, -1},
  { 9, 10,  2,  0,  9,  2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},


  { 2,  3,  8,  2,  8, 10,  0,  1,  8,  1, 10,  8, -1, -1, -1, -1},
  { 1, 10,  2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 1,  3,  8,  9,  1,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 0,  9,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 0,  3,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
};

/*
 * Contains arrays indicating which vertices are connected to a triangle for
 * case 3. Vertices have indices from 0 to 11, three following entries create a
 * triangle. -1 marks the point after which no more triangles are in the array.
 * The entries are separated into the six faces of the voxel. Every four
 * entries are for the same corner configuration with the second two being the
 * flipped surface of the first two.
 * No separate edge table is needed as all vertices are the same as in the
 * default edgeTable.
*/
static const int triTableCase3[48][13] = {
  // Bottom Face
  { 0,  8,  3,  4,  9,  5, -1, -1, -1, -1, -1, -1, -1},
  { 0,  9,  3,  3,  4,  8,  3,  9,  5,  3,  5,  4, -1},
  { 0,  3,  8,  4,  5,  9, -1, -1, -1, -1, -1, -1, -1},
  { 0,  3,  9,  3,  8,  4,  3,  5,  9,  3,  4,  5, -1},

  { 0,  1,  9,  4,  7,  8, -1, -1, -1, -1, -1, -1, -1},
  { 1,  9,  4,  0,  1,  8,  1,  4,  7,  1,  7,  8, -1},
  { 0,  9,  1,  4,  8,  7, -1, -1, -1, -1, -1, -1, -1},
  { 1,  4,  9,  0,  8,  1,  1,  7,  4,  1,  8,  7, -1},
  // Top Face
  { 2,  3, 11,  5, 10,  6, -1, -1, -1, -1, -1, -1, -1},
  { 3, 11,  6,  2,  3, 10,  3,  6,  5,  3,  5, 10, -1},
  { 2, 11,  3,  5,  6, 10, -1, -1, -1, -1, -1, -1, -1},
  { 3,  6, 11,  2, 10,  3,  3,  5,  6,  3, 10,  5, -1},

  { 1,  2, 10,  6, 11,  7, -1, -1, -1, -1, -1, -1, -1},
  { 1,  2, 11,  1,  6, 10,  1, 11,  7,  1,  7,  6, -1},
  { 1, 10,  2,  6,  7, 11, -1, -1, -1, -1, -1, -1, -1},
  { 1, 11,  2,  1, 10,  6,  1,  7, 11,  1,  6,  7, -1},
  // Front Face
  { 0,  8,  3,  1,  2, 10, -1, -1, -1, -1, -1, -1, -1},
  { 2,  8,  3,  0,  8,  1,  2, 10,  8,  1,  8, 10, -1},
  { 0,  3,  8,  1, 10,  2, -1, -1, -1, -1, -1, -1, -1},
  { 2,  3,  8,  0,  1,  8,  2,  8, 10,  1, 10,  8, -1},

  { 2,  3, 11,  0,  1,  9, -1, -1, -1, -1, -1, -1, -1},
  { 0,  3,  9,  1,  9,  2,  3, 11,  9,  2,  9, 11, -1},
  { 2, 11,  3,  0,  9,  1, -1, -1, -1, -1, -1, -1, -1},
  { 0,  9,  3,  1,  2,  9,  3,  9, 11,  2, 11,  9, -1},
  // Right Face
  { 9,  0,  1,  5, 10,  6, -1, -1, -1, -1, -1, -1, -1},
  {10,  0,  1,  9,  0,  5, 10,  6,  0,  5,  0,  6, -1},
  { 9,  1,  0,  5,  6, 10, -1, -1, -1, -1, -1, -1, -1},
  {10,  1,  0,  9,  5,  0, 10,  0,  6,  5,  6,  0, -1},

  {10,  1,  2,  9,  5,  4, -1, -1, -1, -1, -1, -1, -1},
  { 9,  1,  4,  5,  4, 10,  1,  2,  4, 10,  4,  2, -1},
  {10,  2,  1,  9,  4,  5, -1, -1, -1, -1, -1, -1, -1},
  { 9,  4,  1,  5, 10,  4,  1,  4,  2, 10,  2,  4, -1},
  // Back Face
  { 4,  9,  5,  7,  6, 11, -1, -1, -1, -1, -1, -1, -1},
  { 6,  9,  5,  4,  9,  7,  6, 11,  9,  7,  9, 11, -1},
  { 4,  5,  9,  7, 11,  6, -1, -1, -1, -1, -1, -1, -1},
  { 6,  5,  9,  4,  7,  9,  6,  9, 11,  7, 11,  9, -1},

  { 6,  5, 10,  4,  7,  8, -1, -1, -1, -1, -1, -1, -1},
  { 4,  5,  8,  7,  8,  6,  5, 10,  8,  6,  8, 10, -1},
  { 6, 10,  5,  4,  8,  7, -1, -1, -1, -1, -1, -1, -1},
  { 4,  8,  5,  7,  6,  8,  5,  8, 10,  6, 10,  8, -1},
  // Left Face
  { 8,  4,  7,  3, 11,  2, -1, -1, -1, -1, -1, -1, -1},
  {11,  4,  7,  8,  4,  3, 11,  2,  4,  3,  4,  2, -1},
  { 8,  7,  4,  3,  2, 11, -1, -1, -1, -1, -1, -1, -1},
  {11,  7,  4,  8,  3,  4, 11,  4,  2,  3,  2,  4, -1},

  {11,  7,  6,  8,  3,  0, -1, -1, -1, -1, -1, -1, -1},
  { 8,  7,  0,  3,  0, 11,  7,  6,  0, 11,  0,  6, -1},
  {11,  6,  7,  8,  0,  3, -1, -1, -1, -1, -1, -1, -1},
  { 8,  0,  7,  3, 11,  0,  7,  0,  6, 11,  6,  0, -1},
};

/*
 * Contains arrays indicating which vertices are connected to a triangle for
 * case 4. Vertices have indices from 0 to 11, three following entries create a
 * triangle. -1 marks the point after which no more triangles are in the array.
 * The entries are separated into the four diagonals of the voxel. Every four
 * entries are for the same corner configuration. The second two entries create
 * the flipped surface of the first two.
 * No separate edge table is needed as all vertices are the same as in the
 * default edgeTable.
*/
static const int triTableCase4[16][19] = {
  // First Diagonal
  { 0,  8,  3,  5, 10,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 0, 10,  3,  0,  5, 10,  0,  8,  5,  5,  8,  6,  3,  6,  8,  3, 10,  6, -1},
  { 0,  3,  8,  5,  6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 0,  3, 10,  0, 10,  5,  0,  5,  8,  5,  6,  8,  3,  8,  6,  3,  6, 10, -1},
  // Second Diagonal
  { 0,  1,  9, 11,  7,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 9,  6,  1,  9,  7,  6,  9,  0,  7,  7,  0, 11,  1, 11,  0,  1,  6, 11, -1},
  { 0,  9,  1, 11,  6,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 9,  1,  6,  9,  6,  7,  9,  7,  0,  7, 11,  0,  1,  0, 11,  1, 11,  6, -1},
  // Third Diagonal
  { 9,  5,  4,  2,  3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 4, 11,  5,  4,  3, 11,  4,  9,  3,  3,  9,  2,  5,  2,  9,  5,  2, 11, -1},
  { 9,  4,  5,  2, 11,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 4,  5, 11,  4, 11,  3,  4,  3,  9,  3,  2,  9,  5,  9,  2,  5, 11,  2, -1},
  // Fourth Diagonal
  { 1,  2, 10,  8,  4,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 2,  7,  8,  8,  1,  2,  8,  4,  1,  1,  4, 10,  7, 10,  4,  7, 10,  2, -1},
  { 1, 10,  2,  8,  7,  4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 2,  8,  7,  8,  2,  1,  8,  1,  4,  1, 10,  4,  7,  4, 10,  7,  2, 10, -1},
};

/*
 * Contains arrays indicating which vertices are connected to a triangle for
 * case 6. Vertices have indices from 0 to 11, three following entries create a
 * triangle. -1 marks the point after which no more triangles are in the array.
 * The entries are separated into neighbouring positiv corners + the ambiguous
 * face as seen from the front. Each 6 entries belong to the same corner
 * configuration with the second three being creating the flipped surface of the
 * first three.
 * No separate edge table is needed as all vertices are the same as in the
 * default edgeTable.
*/
static const int triTableCase6[144][22] = {
  // Front Bottom + Left
  { 1,  8,  3,  1,  9,  8,  6, 11,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 3, 11,  8,  7,  8, 11,  1, 11,  3,  1,  6, 11,  1,  9,  6,  6,  9,  7,  7,  9,  8, -1},
  { 1, 11,  3,  1,  6, 11,  1,  9,  6,  6,  9,  7,  7,  9,  8, -1, -1, -1, -1, -1, -1, -1},

  { 1,  3,  8,  1,  8,  9,  6,  7, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 3,  8, 11,  7, 11,  8,  1,  3, 11,  1, 11,  6,  1,  6,  9,  6,  7,  9,  7,  8,  9, -1},
  { 1,  3, 11,  1, 11,  6,  1,  6,  9,  6,  7,  9,  7,  8,  9, -1, -1, -1, -1, -1, -1, -1},
  // Front Bottom + Right
  { 1,  8,  3,  1,  9,  8,  5, 10,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 1,  9, 10,  5, 10,  9,  1, 10,  3,  3, 10,  6,  3,  6,  8,  5,  8,  6,  5,  9,  8, -1},
  { 1, 10,  3,  3, 10,  6,  3,  6,  8,  5,  8,  6,  5,  9,  8, -1, -1, -1, -1, -1, -1, -1},

  { 1,  3,  8,  1,  8,  9,  5,  6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 1, 10,  9,  5,  9, 10,  1,  3, 10,  3,  6, 10,  3,  8,  6,  5,  6,  8,  5,  8,  9, -1},
  { 1,  3, 10,  3,  6, 10,  3,  8,  6,  5,  6,  8,  5,  8,  9, -1, -1, -1, -1, -1, -1, -1},
  // Front Right + Bottom
  { 0,  2,  9,  2, 10,  9,  4,  7,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 9,  8,  4,  8,  4,  0,  9,  4, 10, 10,  4,  7, 10,  7,  2,  8,  2,  7,  8,  0,  2, -1},
  { 9,  4, 10, 10,  4,  7, 10,  7,  2,  8,  2,  7,  8,  0,  2, -1, -1, -1, -1, -1, -1, -1},

  { 0,  9,  2,  2,  9, 10,  4,  8,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 9,  4,  8,  8,  0,  4,  9, 10,  4, 10,  7,  4, 10,  2,  7,  8,  7,  2,  8,  2,  0, -1},
  { 9, 10,  4, 10,  7,  4, 10,  2,  7,  8,  7,  2,  8,  2,  0, -1, -1, -1, -1, -1, -1, -1},
  // Front Right + Top
  { 0,  2,  9,  2, 10,  9,  6, 11,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  {10,  2,  6, 11,  6,  2,  9,  6, 10,  9,  7,  6,  9,  0,  7,  7,  0, 11, 11,  0,  2, -1},
  { 9,  6, 10,  9,  7,  6,  9,  0,  7,  7,  0, 11, 11,  0,  2, -1, -1, -1, -1, -1, -1, -1},

  { 0,  9,  2,  2,  9, 10,  6,  7, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  {10,  6,  2, 11,  2,  6,  9, 10,  6,  9,  6,  7,  9,  7,  0,  7, 11,  0, 11,  2,  0, -1},
  { 9, 10,  6,  9,  6,  7,  9,  7,  0,  7, 11,  0, 11,  2,  0, -1, -1, -1, -1, -1, -1, -1},
  // Front Top + Right
  { 1,  3, 10,  3, 11, 10,  4,  9,  5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 1,  9, 10,  5, 10,  9,  1,  3,  9,  3,  4,  9,  3, 11,  4,  4, 11,  5,  5, 11, 10, -1},
  { 1,  3,  9,  3,  4,  9,  3, 11,  4,  4, 11,  5,  5, 11, 10, -1, -1, -1, -1, -1, -1, -1},

  { 1, 10,  3,  3, 10, 11,  4,  5,  9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 1, 10,  9,  5,  9, 10,  1,  9,  3,  3,  9,  4,  3,  4, 11,  4,  5, 11,  5, 10, 11, -1},
  { 1,  9,  3,  3,  9,  4,  3,  4, 11,  4,  5, 11,  5, 10, 11, -1, -1, -1, -1, -1, -1, -1},
  // Front Top + Left
  { 1,  3, 10,  3, 11, 10,  4,  7,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 3, 11,  8,  7,  8, 11,  1,  3,  8,  1,  8,  4,  1,  4, 10,  4,  7, 10,  7, 11, 10, -1},
  { 1,  3,  8,  1,  8,  4,  1,  4, 10,  4,  7, 10,  7, 11, 10, -1, -1, -1, -1, -1, -1, -1},

  { 1, 10,  3,  3, 10, 11,  4,  8,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 3,  8, 11,  7, 11,  8,  1,  8,  3,  1,  4,  8,  1, 10,  4,  4, 10,  7,  7, 10, 11, -1},
  { 1,  8,  3,  1,  4,  8,  1, 10,  4,  4, 10,  7,  7, 10, 11, -1, -1, -1, -1, -1, -1, -1},
  // Front Left + Top
  { 0, 11,  2,  0,  8, 11,  5, 10,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 2, 11, 10,  6, 10, 11,  0, 10,  2,  0,  5, 10,  0,  8,  5,  5,  8,  6,  6,  8, 11, -1},
  { 0, 10,  2,  0,  5, 10,  0,  8,  5,  5,  8,  6,  6,  8, 11, -1, -1, -1, -1, -1, -1, -1},

  { 0,  2, 11,  0, 11,  8,  5,  6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 2, 10, 11,  6, 11, 10,  0,  2, 10,  0, 10,  5,  0,  5,  8,  5,  6,  8,  6, 11,  8, -1},
  { 0,  2, 10,  0, 10,  5,  0,  5,  8,  5,  6,  8,  6, 11,  8, -1, -1, -1, -1, -1, -1, -1},
  // Front Left + Bottom
  { 0, 11,  2,  0,  8, 11,  4,  9,  5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 0,  4,  9,  4,  9,  8,  0,  9,  2,  2,  9,  5,  2,  5, 11,  4, 11,  5,  4,  8, 11, -1},
  { 0,  9,  2,  2,  9,  5,  2,  5, 11,  4, 11,  5,  4,  8, 11, -1, -1, -1, -1, -1, -1, -1},

  { 0,  2, 11,  0, 11,  8,  4,  5,  9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 0,  9,  4,  4,  8,  9,  0,  2,  9,  2,  5,  9,  2, 11,  5,  4,  5, 11,  4, 11,  8, -1},
  { 0,  2,  9,  2,  5,  9,  2, 11,  5,  4,  5, 11,  4, 11,  8, -1, -1, -1, -1, -1, -1, -1},


  // Back Bottom + Left
  { 5,  7,  9,  7,  8,  9,  2,  3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 7,  8, 11,  3, 11,  8,  7, 11,  5,  5, 11,  2,  5,  2,  9,  3,  9,  2,  3,  8,  9, -1},
  { 7, 11,  5,  5, 11,  2,  5,  2,  9,  3,  9,  2,  3,  8,  9, -1, -1, -1, -1, -1, -1, -1},

  { 5,  9,  7,  7,  9,  8,  2, 11,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 7, 11,  8,  3,  8, 11,  7,  5, 11,  5,  2, 11,  5,  9,  2,  3,  2,  9,  3,  9,  8, -1},
  { 7,  5, 11,  5,  2, 11,  5,  9,  2,  3,  2,  9,  3,  9,  8, -1, -1, -1, -1, -1, -1, -1},
  // Back Bottom + Right
  { 5,  7,  9,  7,  8,  9,  1,  2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 5, 10,  9,  1,  9, 10,  7, 10,  5,  7,  2, 10,  7,  8,  2,  2,  8,  1,  1,  8,  9, -1},
  { 7, 10,  5,  7,  2, 10,  7,  8,  2,  2,  8,  1,  1,  8,  9, -1, -1, -1, -1, -1, -1, -1},

  { 5,  9,  8,  7,  9,  8,  1, 10,  2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 5,  9, 10,  1, 10,  9,  7,  5, 10,  7, 10,  2,  7,  2,  8,  2,  1,  8,  1,  9,  8, -1},
  { 7,  5, 10,  7, 10,  2,  7,  2,  8,  2,  1,  8,  1,  9,  8, -1, -1, -1, -1, -1, -1, -1},
  // Back Right + Bottom
  { 4, 10,  6,  4,  9, 10,  0,  8,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 4,  0,  8,  0,  8,  9,  4,  8,  6,  6,  8,  3,  6,  3, 10,  0, 10,  3,  0,  9, 10, -1},
  { 4,  8,  6,  6,  8,  3,  6,  3, 10,  0, 10,  3,  0,  9, 10, -1, -1, -1, -1, -1, -1, -1},

  { 4,  6, 10,  4, 10,  9,  0,  3,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 4,  8,  0,  0,  9,  8,  4,  6,  8,  6,  3,  8,  6, 10,  3,  0,  3, 10,  0, 10,  9, -1},
  { 4,  6,  8,  6,  3,  8,  6, 10,  3,  0,  3, 10,  0, 10,  9, -1, -1, -1, -1, -1, -1, -1},
  // Back Right + Top
  { 4, 10,  6,  4,  9, 10,  2,  3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 6, 10, 11,  2, 11, 10,  4, 11,  6,  4,  3, 11,  4,  9,  3,  3,  9,  2,  2,  9, 10, -1},
  { 4, 11,  6,  4,  3, 11,  4,  9,  3,  3,  9,  2,  2,  9, 10, -1, -1, -1, -1, -1, -1, -1},

  { 4,  6, 10,  4, 10,  9,  2, 11,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 6, 11, 10,  2, 10, 11,  4,  6, 11,  4, 11,  3,  4,  3,  9,  3,  2,  9,  2, 10,  9, -1},
  { 4,  6, 11,  4, 11,  3,  4,  3,  9,  3,  2,  9,  2, 10,  9, -1, -1, -1, -1, -1, -1, -1},
  // Back Top + Right
  { 5, 11,  7,  5, 10, 11,  0,  1,  9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 5, 10,  9,  1,  9, 10,  7,  5,  9,  7,  9,  0,  7,  0, 11,  0,  1, 11,  1, 10, 11, -1},
  { 7,  5,  9,  7,  9,  0,  7,  0, 11,  0,  1, 11,  1, 10, 11, -1, -1, -1, -1, -1, -1, -1},

  { 5,  7, 11,  5, 11, 10,  0,  9,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 5,  9, 10,  1, 10,  9,  7,  9,  5,  7,  0,  9,  7, 11,  0,  0, 11,  1,  1, 11, 10, -1},
  { 7,  9,  5,  7,  0,  9,  7, 11,  0,  0, 11,  1,  1, 11, 10, -1, -1, -1, -1, -1, -1, -1},
  // Back Top + Left
  { 5, 11,  7,  5, 10, 11,  0,  8,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 7,  8, 11,  3, 11,  8,  7,  5,  8,  5,  0,  8,  5, 10,  0,  0, 10,  3,  3, 10, 11, -1},
  { 7,  5,  8,  5,  0,  8,  5, 10,  0,  0, 10,  3,  3, 10, 11, -1, -1, -1, -1, -1, -1, -1},

  { 5,  7, 11,  5, 11, 10,  0,  3,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 7, 11,  8,  3,  8, 11,  7,  8,  5,  5,  8,  0,  5,  0, 10,  0,  3, 10,  3, 11, 10, -1},
  { 7,  8,  5,  5,  8,  0,  5,  0, 10,  0,  3, 10,  3, 11, 10, -1, -1, -1, -1, -1, -1, -1},
  // Back Left + Top
  { 4,  6,  8,  6, 11,  8,  1,  2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  {11,  6,  2, 10,  2,  6,  8,  2, 11,  8,  1,  2,  8,  4,  1,  1,  4, 10, 10,  4,  6, -1},
  { 8,  2, 11,  8,  1,  2,  8,  4,  1,  1,  4, 10, 10,  4,  6, -1, -1, -1, -1, -1, -1, -1},

  { 4,  8,  6,  6,  8, 11,  1, 10,  2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  {11,  2,  6, 10,  6,  2,  8, 11,  2,  8,  2,  1,  8,  1,  4,  1, 10,  4, 10,  6,  4, -1},
  { 8, 11,  2,  8,  2,  1,  8,  1,  4,  1, 10,  4, 10,  6,  4, -1, -1, -1, -1, -1, -1, -1},
  // Back Left + Bottom
  { 4,  6,  8,  6, 11,  8,  0,  1,  9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 8,  9,  0,  9,  0,  4,  8,  0, 11, 11,  0,  1, 11,  1,  6,  9,  6,  1,  9,  4,  6, -1},
  { 8,  0, 11, 11,  0,  1, 11,  1,  6,  9,  6,  1,  9,  4,  6, -1, -1, -1, -1, -1, -1, -1},

  { 4,  8,  6,  6,  8, 11,  0,  9,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 8,  0,  9,  9,  4,  0,  8, 11,  0, 11,  1,  0, 11,  6,  1,  9,  1,  6,  9,  6,  4, -1},
  { 8, 11,  0, 11,  1,  0, 11,  6,  1,  9,  1,  6,  9,  6,  4, -1, -1, -1, -1, -1, -1, -1},


  // Left Bottom + Front
  { 3,  4,  7,  0,  4,  3,  1,  2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 3,  0,  2,  1,  2,  0,  3,  2,  7,  7,  2, 10,  7, 10,  4,  1,  4, 10,  1,  0,  4, -1},
  { 3,  2,  7,  7,  2, 10,  7, 10,  4,  1,  4, 10,  1,  0,  4, -1, -1, -1, -1, -1, -1, -1},

  { 3,  7,  4,  0,  3,  4,  1, 10,  2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 3,  2,  0,  1,  0,  2,  3,  7,  2,  7, 10,  2,  7,  4, 10,  1, 10,  4,  1,  4,  0, -1},
  { 3,  7,  2,  7, 10,  2,  7,  4, 10,  1, 10,  4,  1,  4,  0, -1, -1, -1, -1, -1, -1, -1},
  // Left Bottom + Back
  { 3,  4,  7,  0,  4,  3,  5, 10,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 7,  6,  4,  5,  4,  6,  3,  6,  7,  3, 10,  6,  3,  0, 10, 10,  0,  5,  5,  0,  4, -1},
  { 3,  6,  7,  3, 10,  6,  3,  0, 10, 10,  0,  5,  5,  0,  4, -1, -1, -1, -1, -1, -1, -1},

  { 3,  7,  4,  0,  3,  4,  5,  6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 7,  4,  6,  5,  6,  4,  3,  7,  6,  3,  6, 10,  3, 10,  0, 10,  5,  0,  5,  4,  0, -1},
  { 3,  7,  6,  3,  6, 10,  3, 10,  0, 10,  5,  0,  5,  4,  0, -1, -1, -1, -1, -1, -1, -1},
  // Right Bottom + Front
  { 0,  1,  5,  0,  5,  4,  2,  3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 1,  2,  0,  3,  0,  2,  5,  2,  1,  5, 11,  2,  5,  4, 11, 11,  4,  3,  3,  4,  0, -1},
  { 5,  2,  1,  5, 11,  2,  5,  4, 11, 11,  4,  3,  3,  4,  0, -1, -1, -1, -1, -1, -1, -1},

  { 0,  5,  1,  0,  4,  5,  2, 11,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 1,  0,  2,  3,  2,  0,  5,  1,  2,  5,  2, 11,  5, 11,  4, 11,  3,  4,  3,  0,  4, -1},
  { 5,  1,  2,  5,  2, 11,  5, 11,  4, 11,  3,  4,  3,  0,  4, -1, -1, -1, -1, -1, -1, -1},
  // Right Bottom + Back
  { 0,  1,  5,  0,  5,  4,  6, 11,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 5,  4,  6,  7,  6,  4,  5,  6,  1,  1,  6, 11,  1, 11,  0,  7,  0, 11,  7,  4,  0, -1},
  { 5,  6,  1,  1,  6, 11,  1, 11,  0,  7,  0, 11,  7,  4,  0, -1, -1, -1, -1, -1, -1, -1},

  { 0,  5,  1,  0,  4,  5,  6,  7, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 5,  6,  4,  7,  4,  6,  5,  1,  6,  1, 11,  6,  1,  0, 11,  7, 11,  0,  7,  0,  4, -1},
  { 5,  1,  6,  1, 11,  6,  1,  0, 11,  7, 11,  0,  7,  0,  4, -1, -1, -1, -1, -1, -1, -1},
  // Right Top + Front
  { 1,  6,  5,  1,  2,  6,  0,  8,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 1,  2,  0,  3,  0,  2,  5,  1,  0,  5,  0,  8,  5,  8,  6,  8,  3,  6,  3,  2,  6, -1},
  { 5,  1,  0,  5,  0,  8,  5,  8,  6,  8,  3,  6,  3,  2,  6, -1, -1, -1, -1, -1, -1, -1},

  { 1,  5,  6,  1,  6,  2,  0,  3,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 1,  0,  2,  3,  2,  0,  5,  0,  1,  5,  8,  0,  5,  6,  8,  8,  6,  3,  3,  6,  2, -1},
  { 5,  0,  1,  5,  8,  0,  5,  6,  8,  8,  6,  3,  3,  6,  2, -1, -1, -1, -1, -1, -1, -1},
  // Right Top + Back
  { 1,  6,  5,  1,  2,  6,  4,  7,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 5,  4,  6,  7,  6,  4,  5,  1,  4,  1,  8,  4,  1,  2,  8,  8,  2,  7,  7,  2,  6, -1},
  { 5,  1,  4,  1,  8,  4,  1,  2,  8,  8,  2,  7,  7,  2,  6, -1, -1, -1, -1, -1, -1, -1},

  { 1,  5,  6,  1,  6,  2,  4,  8,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 5,  6,  4,  7,  4,  6,  5,  4,  1,  1,  4,  8,  1,  8,  2,  8,  7,  2,  7,  6,  2, -1},
  { 5,  4,  1,  1,  4,  8,  1,  8,  2,  8,  7,  2,  7,  6,  2, -1, -1, -1, -1, -1, -1, -1},
  // Left Top + Front
  { 2,  3,  7,  7,  6,  2,  0,  1,  9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 3,  0,  2,  1,  2,  0,  3,  7,  0,  0,  7,  9,  7,  6,  9,  9,  6,  1,  1,  6,  2, -1},
  { 3,  7,  0,  0,  7,  9,  7,  6,  9,  9,  6,  1,  1,  6,  2, -1, -1, -1, -1, -1, -1, -1},

  { 2,  7,  3,  7,  2,  6,  0,  9,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 3,  2,  0,  1,  0,  2,  3,  0,  7,  0,  9,  7,  7,  9,  6,  9,  1,  6,  1,  2,  6, -1},
  { 3,  0,  7,  0,  9,  7,  7,  9,  6,  9,  1,  6,  1,  2,  6, -1, -1, -1, -1, -1, -1, -1},
  // Left Top + Back
  { 2,  7,  3,  2,  6,  7,  4,  9,  5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 7,  6,  4,  5,  4,  6,  3,  7,  4,  3,  4,  9,  3,  9,  2,  9,  5,  2,  5,  6,  2, -1},
  { 3,  7,  4,  3,  4,  9,  3,  9,  2,  9,  5,  2,  5,  6,  2, -1, -1, -1, -1, -1, -1, -1},

  { 2,  3,  7,  2,  7,  6,  4,  5,  9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  { 7,  4,  6,  5,  6,  4,  3,  4,  7,  3,  9,  4,  3,  2,  9,  9,  2,  5,  5,  2,  6, -1},
  { 3,  4,  7,  3,  9,  4,  3,  2,  9,  9,  2,  5,  5,  2,  6, -1, -1, -1, -1, -1, -1, -1},
};

/*
 * Contains arrays indicating which vertices are connected to a triangle for
 * case 7. Vertices have indices from 0 to 12, three following entries create a
 * triangle. -1 marks the point after which no more triangles are in the array.
 * The entries are separated by their common corner with the second nine entries
 * creating the flipped surface of the first nine.
 * The common corner is the corner present in all three ambiguous faces of the
 * voxel.
 * Because there are 13 vertices a seperate edge table is needed.
*/
static const int triTableCase7[144][28] = {
  // Front Top Right
  { 2,  3, 11,  5, 10,  6,  0,  1,  9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.1
  { 6,  5,  9,  6,  9,  0,  6,  0,  1,  6,  1, 10,  2,  3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_3
  { 5, 10,  2,  5,  2,  3,  5,  3, 10,  5, 10,  6,  0,  9,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_1
  { 3, 11, 12, 11,  6, 12,  6,  5, 12,  5,  9, 12,  9,  0, 12,  0,  1, 12,  1, 10, 12, 10,  2, 12,  2,  3, 12, -1}, // 7.3_1
  { 9,  0,  3,  9,  3, 11,  9, 11,  2,  9,  2,  1,  5, 10,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_2
  { 6,  5, 12,  5,  9, 12,  9,  0, 12,  0,  3, 12,  3, 11, 12, 11,  2, 12,  2,  1, 12,  1, 10, 12, 10,  6, 12, -1}, // 7.3_3
  { 9,  0, 12,  0,  3, 12,  3, 11, 12, 11,  6, 12,  6,  5, 12,  5, 10, 12, 10,  2, 12,  2,  1, 12,  1,  9, 12, -1}, // 7.3_2
  {11,  5,  0,  0,  3, 11, 11,  6,  5,  5,  9,  0,  1, 10,  2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.4.1
  { 2,  3, 11,  5, 10,  6,  0,  1,  9,  0,  3,  2,  2,  1,  0,  9,  1, 10, 10,  5,  9,  2, 11,  6,  6, 10,  2, -1}, // 7.4.2

  { 2, 11,  3,  5,  6, 10,  0,  9,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.1
  { 6,  9,  5,  6,  0,  9,  6,  1,  0,  6, 10,  1,  2, 11,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_3
  { 5,  2, 10,  5,  3,  2,  5, 10,  3,  5,  6, 10,  0,  1,  9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_1
  { 3, 12, 11, 11, 12,  6,  6, 12,  5,  5, 12,  9,  9, 12,  0,  0, 12,  1,  1, 12, 10, 10, 12,  2,  2, 12,  3, -1}, // 7.3_1
  { 9,  3,  0,  9, 11,  3,  9,  2, 11,  9,  1,  2,  5,  6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_2
  { 6, 12,  5,  5, 12,  9,  9, 12,  0,  0, 12,  3,  3, 12, 11, 11, 12,  2,  2, 12,  1,  1, 12, 10, 10, 12,  6, -1}, // 7.3_3
  { 9, 12,  0,  0, 12,  3,  3, 12, 11, 11, 12,  6,  6, 12,  5,  5, 12, 10, 10, 12,  2,  2, 12,  2,  1, 12,  9, -1}, // 7.3_2
  {11,  0,  5,  0, 11,  3, 11,  5,  6,  5,  0,  9,  1,  2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.4.1
  { 2, 11,  3,  5,  6, 10,  0,  9,  1,  0,  2,  3,  2,  0,  1,  9, 10,  1, 10,  9,  5,  2,  6, 11,  6,  2, 10, -1}, // 7.4.2
  // Back Top Right
  { 1,  2, 10,  6, 11,  7,  4,  9,  5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.1
  {11,  7,  4, 11,  4,  9, 11,  9,  5, 11,  5,  6,  1,  2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_3
  { 7,  6, 10,  7, 10,  1,  7,  1,  2,  7,  1, 11,  4,  5,  9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_1
  { 1,  2, 12,  2, 11, 12, 11,  7, 12,  7,  4, 12,  4,  9, 12,  9,  5, 12,  5,  6, 12,  6, 10, 12, 10,  1, 12, -1}, // 7.3_1
  { 4, 10,  5,  4,  2, 10,  4,  1,  2,  4,  9,  1,  6, 11,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_2
  {11,  7, 12,  7,  4, 12,  4,  9, 12,  9,  1, 12,  1,  2, 12,  2, 10, 12, 10,  5, 12,  5,  6, 12,  6, 11, 12, -1}, // 7.3_3
  { 4,  9, 12,  9,  1, 12,  1,  2, 12,  2, 11, 12, 11,  7, 12,  7,  6, 12,  6, 10, 12, 10,  5, 12,  5,  4, 12, -1}, // 7.3_2
  { 2,  7,  9,  9,  1,  2,  2, 11,  7,  7,  4,  9,  5,  6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.4.1
  { 1,  2, 10,  6, 11,  7,  4,  9,  5,  9,  1, 10, 10,  5,  9,  4,  5,  6,  6,  7,  4, 10,  2, 11, 11,  6, 10, -1}, // 7.4.2

  { 1, 10,  2,  6,  7, 11,  4,  5,  9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.1
  {11,  4,  7, 11,  9,  4, 11,  5,  9, 11,  6,  5,  1, 10,  2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_3
  { 7, 10,  6,  7,  1, 10,  7,  2,  1,  7, 11,  1,  4,  9,  5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_1
  { 1, 12,  2,  2, 12, 11, 11, 12,  7,  7, 12,  4,  4, 12,  9,  9, 12,  5,  5, 12,  6,  6, 12, 10, 10, 12,  1, -1}, // 7.3_1
  { 4,  5, 10,  4, 10,  2,  4,  2,  1,  4,  1,  9,  6,  7, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_2
  {11, 12,  7,  7, 12,  4,  4, 12,  9,  9, 12,  1,  1, 12,  2,  2, 12, 10, 10, 12,  5,  5, 12,  6,  6, 12, 11, -1}, // 7.3_3
  { 4, 12,  9,  9, 12,  1,  1, 12,  2,  2, 12, 11, 11, 12,  7,  7, 12,  6,  6, 12, 10, 10, 12,  5,  5, 12,  4, -1}, // 7.3_2
  { 2,  9,  7,  9,  2,  1,  2,  7, 11,  7,  9,  4,  5, 10,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.4.1
  { 1, 10,  2,  6,  7, 11,  4,  5,  9,  9, 10,  1, 10,  9,  5,  4,  6,  5,  6,  4,  7, 10, 11,  2, 11, 10,  6, -1}, // 7.4.2
  // Back Top Left
  { 2,  3, 11,  5, 10,  6,  4,  7,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.1
  { 2,  3,  8,  2,  8,  4,  2,  4,  7,  2,  7, 11,  5, 10,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_3
  { 3, 11,  6,  3,  6,  5,  3,  5, 10,  3,  5,  2,  4,  7,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_1
  { 5, 10, 12, 10,  2, 12,  2,  3, 12,  3,  8, 12,  8,  4, 12,  4,  7, 12,  7, 11, 12, 11,  6, 12,  6,  5, 12, -1}, // 7.3_1
  { 8,  4,  5,  8,  5, 10,  8, 10,  6,  8,  6,  7,  2,  3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_2
  { 2,  3, 12,  3,  8, 12,  8,  4, 12,  4,  5, 12,  5, 10, 12, 10,  6, 12,  6,  7, 12,  7, 11, 12, 11,  2, 12, -1}, // 7.3_3
  { 8,  4, 12,  4,  5, 12,  5, 10, 12, 10,  2, 12,  2,  3, 12,  3, 11, 12, 11,  6, 12,  6,  7, 12,  7,  8, 12, -1}, // 7.3_2
  {10,  3,  4,  4,  5, 10, 10,  2,  3,  3,  8,  4,  6,  7, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.4.1
  { 2,  3, 11,  5, 10,  6,  4,  7,  8,  4,  5,  6,  6,  7,  4,  8,  7, 11, 11,  3,  8,  2, 11,  6,  6, 10,  2, -1}, // 7.4.2

  { 2, 11,  3,  5,  6, 10,  4,  8,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.1
  { 2,  8,  3,  2,  4,  8,  2,  7,  4,  2, 11,  7,  5,  6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_3
  { 3,  6, 11,  3,  5,  6,  3, 10,  5,  3,  2,  5,  4,  8,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_1
  { 5, 12, 10, 10, 12,  2,  2, 12,  3,  3, 12,  8,  8, 12,  4,  4, 12,  7,  7, 12, 11, 11, 12,  6,  6, 12,  5, -1}, // 7.3_1
  { 8,  5,  4,  8, 10,  5,  8,  6, 10,  8,  7,  6,  2, 11,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_2
  { 2, 12,  3,  3, 12,  8,  8, 12,  4,  4, 12,  5,  5, 12, 10, 10, 12,  6,  6, 12,  7,  7, 12, 11, 11, 12,  2, -1}, // 7.3_3
  { 8, 12,  4,  4, 12,  5,  5, 12, 10, 10, 12,  2,  2, 12,  3,  3, 12, 11, 11, 12,  6,  6, 12,  7,  7, 12,  8, -1}, // 7.3_2
  {10,  4,  3,  4, 10,  5, 10,  3,  2,  3,  4,  8,  6, 11,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.4.1
  { 2, 11,  3,  5,  6, 10,  4,  8,  7,  4,  6,  5,  6,  4,  7,  8, 11,  7, 11,  8,  3,  2,  6, 11,  6,  2, 10, -1}, // 7.4.2
  // Front Top Left
  { 1,  2, 10,  6, 11,  7,  0,  8,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.1
  {10,  1,  0, 10,  0,  8, 10,  8,  3, 10,  3,  2,  6, 11,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_3
  { 1,  2, 11,  1, 11,  7,  1,  7,  6,  1,  6, 10,  0,  8,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_1
  { 7,  6, 12,  6, 10, 12, 10,  1, 12,  1,  0, 12,  0,  8, 12,  8,  3, 12,  3,  2, 12,  2, 11, 12, 11,  7, 12, -1}, // 7.3_1
  { 0,  8,  7,  0,  7,  6,  0,  6, 11,  0, 11,  3,  1,  2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_2
  {10,  1, 12,  1,  0, 12,  0,  8, 12,  8,  7, 12,  7,  6, 12,  6, 11, 12, 11,  3, 12,  3,  2, 12,  2, 10, 12, -1}, // 7.3_3
  { 0,  8, 12,  8,  7, 12,  7,  6, 12,  6, 10, 12, 10,  1, 12,  1,  2, 12,  2, 11, 12, 11,  3, 12,  3,  0, 12, -1}, // 7.3_2
  { 6,  1,  8,  8,  7,  6,  6, 10,  1,  1,  0,  8,  3,  2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.4.1
  { 1,  2, 10,  6, 11,  7,  0,  8,  3,  8,  7, 11, 11,  3,  8,  0,  3,  2,  2,  1,  0, 10,  2, 11, 11,  6, 10, -1}, // 7.4.2

  { 1, 10,  2,  6,  7, 11,  0,  3,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.1
  {10,  0,  1, 10,  8,  0, 10,  3,  8, 10,  2,  3,  6,  7, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_3
  { 1, 11,  2,  1,  7, 11,  1,  6,  7,  1, 10,  6,  0,  3,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_1
  { 7, 12,  6,  6, 12, 10, 10,  12,  1,  1, 12, 0,  0, 12,  8,  8, 12,  3,  3, 12,  2,  2, 12, 11, 11, 12,  7, -1}, // 7.3_1
  { 0,  7,  8,  0,  6,  7,  0, 11,  6,  0,  3, 11,  1, 10,  2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_2
  {10, 12,  1,  1, 12,  0,  0, 12,  8,  8, 12,  7,  7, 12,  6,  6, 12, 11, 11, 12,  3,  3, 12,  2,  2, 12, 10, -1}, // 7.3_3
  { 0, 12,  8,  8, 12,  7,  7, 12,  6,  6, 12, 10, 10, 12,  1,  1, 12,  2,  2, 12, 11, 11, 12,  3,  3, 12,  0, -1}, // 7.3_2
  { 6,  8,  1,  8,  6,  7,  6,  1, 10,  1,  8,  0,  3, 11,  2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.4.1
  { 1, 10,  2,  6,  7, 11,  0,  3,  8,  8, 11,  7, 11,  8,  3,  0,  2,  3,  2,  0,  1, 10, 11,  2, 11, 10,  6, -1}, // 7.4.2
  // Front Bottom Right
  { 0,  8,  3,  4,  9,  5,  1,  2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.1
  {10,  1,  0, 10,  0,  8, 10,  8,  3, 10,  3,  2,  4,  9,  5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_3
  { 3,  4,  8,  3,  5,  8,  3,  9,  5,  3,  9,  0,  1,  2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_1
  { 5,  4, 12,  4,  8, 12,  8,  3, 12,  3,  2, 12,  2, 10, 12, 10,  1, 12,  1,  0, 12,  0,  9, 12,  9,  5, 12, -1}, // 7.3_1
  { 2, 10,  5,  2,  5,  4,  2,  4,  9,  2,  9,  1,  0,  8,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_2
  { 8,  3, 12,  3,  2, 12,  2, 11, 12, 11,  5, 12,  5,  4, 12,  4,  9, 12,  9,  1, 12,  1,  0, 12,  0,  8, 12, -1}, // 7.3_3
  { 2, 10, 12, 10,  5, 12,  5,  4, 12,  4,  8, 12,  8,  3, 12,  3,  0, 12,  0,  9, 12,  9,  1, 12,  1,  2, 12, -1}, // 7.3_2
  { 3, 10,  4,  4,  8,  3,  3,  2, 10, 10,  5,  4,  0,  9,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.4.1
  { 0,  8,  3,  4,  9,  5,  1,  2, 10,  0,  3,  2,  2,  1,  0,  9,  1, 10, 10,  5,  9,  4,  8,  0,  0,  9,  4, -1}, // 7.4.2

  { 0,  3,  8,  4,  5,  9,  1, 10,  2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.1
  {10,  0,  1, 10,  8,  0, 10,  3,  8, 10,  2,  3,  4,  5,  9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_3
  { 3,  8,  4,  3,  8,  5,  3,  5,  9,  3,  0,  9,  1, 10,  2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_1
  { 5, 12,  4,  4, 12,  8,  8, 12,  3,  3, 12,  2,  2, 12, 10, 10, 12,  1,  1, 12,  0,  0, 12,  9,  9, 12,  5, -1}, // 7.3_1
  { 2,  5, 10,  2,  4,  5,  2,  9,  4,  2,  1,  9,  0,  3,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_2
  { 8, 12,  3,  3, 12,  2,  2, 12, 11, 11, 12,  5,  5, 12,  4,  4, 12,  9,  9, 12,  1,  1, 12,  0,  0, 12,  8, -1}, // 7.3_3
  { 2, 12, 10, 10, 12,  5,  5, 12,  4,  4, 12,  8,  8, 12,  3,  3, 12,  0,  0, 12,  9,  9, 12,  1,  1, 12,  2, -1}, // 7.3_2
  { 3,  4, 10,  4,  3,  8,  3, 10,  2, 10,  4,  5,  0,  1,  9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.4.1
  { 0,  3,  8,  4,  5,  9,  1, 10,  2,  0,  2,  3,  2,  0,  1,  9, 10,  1, 10,  9,  5,  4,  0,  8,  0,  4,  9, -1}, // 7.4.2
  // Back Bottom Right
  { 0,  1,  9,  4,  7,  8,  5, 10,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.1
  { 0,  1, 10,  0, 10,  6,  0,  6,  5,  0,  5,  9,  4,  7,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_3
  { 1,  8,  0,  1,  7,  8,  1,  4,  7,  1,  9,  4,  5, 10,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_1
  { 7,  8, 12,  8,  0, 12,  0,  1, 12,  1, 10, 12, 10,  6, 12,  6,  5, 12,  5,  9, 12,  9,  4, 12,  4,  7, 12, -1}, // 7.3_1
  {10,  6,  7, 10,  7,  8, 10,  8,  4, 10,  4,  5,  0,  1,  9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_2
  { 0,  1, 12,  1, 10, 12, 11,  6, 12,  6,  7, 12,  7,  8, 12,  8,  4, 12,  4,  5, 12,  5,  9, 12,  9,  0, 12, -1}, // 7.3_3
  {10,  6, 12,  6,  7, 12,  7,  8, 12,  8,  0, 12,  0,  1, 12,  1,  9, 12,  9,  4, 12,  4,  5, 12,  5, 10, 12, -1}, // 7.3_2
  { 1,  6,  8,  8,  0,  1,  1, 10,  6,  6,  7,  8,  9,  4,  5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.4.1
  { 0,  1,  9,  4,  7,  8,  5, 10,  6,  9,  1, 10, 10,  5,  9,  4,  5,  6,  6,  7,  4,  8,  0,  9,  9,  4,  8, -1}, // 7.4.2

  { 0,  9,  1,  4,  8,  7,  5,  6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.1
  { 0, 10,  1,  0,  6, 10,  0,  5,  6,  0,  9,  5,  4,  8,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_3
  { 1,  0,  8,  1,  8,  7,  1,  7,  4,  1,  4,  9,  5,  6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_1
  { 7, 12,  8,  8, 12,  0,  0, 12,  1,  1, 12, 10, 10, 12,  6,  6, 12,  5,  5, 12,  9,  9, 12,  4,  4, 12,  7, -1}, // 7.3_1
  {10,  7,  6, 10,  8,  7, 10,  4,  8, 10,  5,  4,  0,  9,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_2
  { 0, 12,  1,  1, 12, 10, 11, 12,  6,  6, 12,  7,  7, 12,  8,  8, 12,  4,  4, 12,  5,  5, 12,  9,  9, 12,  0, -1}, // 7.3_3
  {10, 12,  6,  6, 12,  7,  7, 12,  8,  8, 12,  0,  0, 12,  1,  1, 12,  9,  9, 12,  4,  4, 12,  5,  5, 12, 10, -1}, // 7.3_2
  { 1,  8,  6,  8,  1,  0,  1,  6, 10,  6,  8,  7,  9,  5,  4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.4.1
  { 0,  9,  1,  4,  8,  7,  5,  6, 10,  9, 10,  1, 10,  9,  5,  4,  6,  5,  6,  4,  7,  8,  9,  0,  9,  8,  4, -1}, // 7.4.2
  // Back Bottom Left
  { 0,  8,  3,  4,  9,  5,  6, 11,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.1
  {11,  7,  4, 11,  4,  9, 11,  9,  5, 11,  5,  6,  0,  8,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_3
  { 5,  4,  8,  5,  8,  3,  5,  3,  0,  5,  0,  9,  6, 11,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_1
  { 3,  0, 12,  0,  9, 12,  9,  5, 12,  5,  6, 12,  6, 11, 12, 11,  7, 12,  7,  4, 12,  4,  8, 12,  8,  3, 12, -1}, // 7.3_1
  { 6, 11,  3,  6,  3,  0,  6,  0,  8,  6,  8,  7,  4,  9,  5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_2
  { 9,  5, 12,  5,  6, 12,  6, 11, 12, 11,  3, 12,  3,  0, 12,  0,  8, 12,  8,  7, 12,  7,  4, 12,  4,  9, 12, -1}, // 7.3_3
  { 6, 11, 12, 11,  3, 12,  3,  0, 12,  0,  9, 12,  9,  5, 12,  5,  4, 12,  4,  8, 12,  8,  7, 12,  7,  6, 12, -1}, // 7.3_2
  { 5, 11,  0,  0,  9,  5,  5,  6, 11, 11,  3,  0,  4,  8,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.4.1
  { 0,  8,  3,  4,  9,  5,  6, 11,  7,  4,  5,  6,  6,  7,  4,  8,  7, 11, 11,  3,  8,  4,  8,  0,  0,  9,  4, -1}, // 7.4.2

  { 0,  3,  8,  4,  5,  9,  6,  7, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.1
  {11,  4,  7, 11,  9,  4, 11,  5,  9, 11,  6,  5,  0,  3,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_3
  { 5,  8,  4,  5,  3,  8,  5,  0,  3,  5,  9,  0,  6,  7, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_1
  { 3, 12,  0,  0, 12,  9,  9, 12,  5,  5, 12,  6,  6, 12, 11, 11, 12,  7,  7, 12,  4,  4, 12,  8,  8, 12,  3, -1}, // 7.3_1
  { 6,  3, 11,  6,  0,  3,  6,  8,  0,  6,  7,  8,  4,  5,  9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_2
  { 9, 12,  5,  5, 12,  6,  6, 12, 11, 11, 12,  3,  3, 12,  0,  0, 12,  8,  8, 12,  7,  7, 12,  4,  4, 12,  9, -1}, // 7.3_3
  { 6, 12, 11, 11, 12,  3,  3, 12,  0,  0, 12,  9,  9, 12,  5,  5, 12,  4,  4, 12,  8,  8, 12,  7,  7, 12,  6, -1}, // 7.3_2
  { 5,  0, 11,  0,  5,  9,  5, 11,  6, 11,  0,  3,  4,  7,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.4.1
  { 0,  3,  8,  4,  5,  9,  6,  7, 11,  4,  6,  5,  6,  4,  7,  8, 11,  7, 11,  8,  3,  4,  0,  8,  0,  4,  9, -1}, // 7.4.2
  // Front Bottom Left
  { 0,  1,  9,  4,  7,  8,  2,  3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.1
  { 4,  7, 11,  4, 11,  2,  4,  2,  3,  4,  3,  8,  0,  1,  9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_3
  { 7,  8,  0,  7,  0,  1,  7,  1,  9,  7,  9,  4,  2, 11,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_1
  { 1,  9, 12,  9,  4, 12,  4,  7, 12,  7, 11, 12, 11,  2, 12,  2,  3, 12,  3,  8, 12,  8,  0, 12,  0,  1, 12, -1}, // 7.3_1
  {11,  2,  1, 11,  1,  9, 11,  9,  0, 11,  0,  3,  4,  7,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_2
  { 4,  7, 12,  7, 11, 12, 11,  2, 12,  2,  1, 12,  1,  9, 12,  9,  0, 12,  0,  3, 12,  3,  8, 12,  8,  4, 12, -1}, // 7.3_3
  {11,  2, 12,  2,  1, 12,  1,  9, 12,  9,  4, 12,  4,  7, 12,  7,  8, 12,  8,  0, 12,  0,  3, 12,  3, 11, 12, -1}, // 7.3_2
  { 7,  2,  9,  9,  4,  7,  7, 11,  2,  2,  1,  9,  8,  0,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.4.1
  { 0,  1,  9,  4,  7,  8,  2,  3, 11,  8,  7, 11, 11,  3,  8,  0,  3,  2,  2,  1,  0,  8,  0,  9,  9,  4,  8, -1}, // 7.4.2

  { 0,  9,  1,  4,  8,  7,  2, 11,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.1
  { 4, 11,  7,  4,  2, 11,  4,  3,  2,  4,  8,  3,  0,  9,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_3
  { 7,  0,  8,  7,  1,  0,  7,  9,  1,  7,  4,  9,  2,  3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_1
  { 1, 12,  9,  9, 12,  4,  4, 12,  7,  7, 12, 11, 11, 12,  2,  2, 12,  3,  3, 12,  8,  8, 12,  0,  0, 12,  1, -1}, // 7.3_1
  {11,  1,  2, 11,  9,  1, 11,  0,  9, 11,  3,  0,  4,  7,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.2_2
  { 4, 12,  7,  7, 12, 11, 11, 12,  2,  2, 12,  1,  1, 12,  9,  9, 12,  0,  0, 12,  3,  3, 12,  8,  8, 12,  4, -1}, // 7.3_3
  {11, 12,  2,  2, 12,  1,  1, 12,  9,  9, 12,  4,  4, 12,  7,  7, 12,  8,  8, 12,  0,  0, 12,  3,  3, 12, 11, -1}, // 7.3_2
  { 7,  9,  2,  9,  7,  4,  7,  2, 11,  2,  9,  1,  8,  3,  0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7.4.1
  { 0,  9,  1,  4,  8,  7,  2, 11,  3,  8, 11,  7, 11,  8,  3,  0,  2,  3,  2,  0,  1,  8,  9,  0,  9,  8,  4, -1}, // 7.4.2
};

/*
 * Contains arrays indicating which vertices are connected to a triangle for
 * case 10. Vertices have indices from 0 to 12, three following entries create a
 * triangle. -1 marks the point after which no more triangles are in the array.
 * The entries are separated into the six diagonally opposing edge pairs. Every
 * four entries are for the same edge configuration. There are no flipped
 * configurations.
 * A separate edge table is needed.
*/
static const int triTableCase10[24][25] = {
  // Bottom Left + Top Right
  { 0,  7,  3,  0,  4,  7,  1,  2,  6,  1,  6,  5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 10.1.1
  { 3,  0,  1,  1,  2,  3,  5,  4,  7,  7,  6,  5,  1,  0,  4,  4,  5,  1,  6,  7,  3,  3,  2,  6, -1}, // 10.1.2
  { 3,  2, 12,  2,  6, 12,  6,  5, 12,  5,  1, 12,  1,  0, 12,  0,  4, 12,  4,  7, 12,  7,  3, 12, -1}, // 10.2 Front
  { 3,  0, 12,  0,  4, 12,  4,  5, 12,  5,  1, 12,  1,  2, 12,  2,  6, 12,  6,  7, 12,  7,  3, 12, -1}, // 10.2 Back

  // Bottom Front + Top Back
  { 3,  9,  8,  3,  1,  9,  5, 11,  7,  5, 10,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 10.1.1
  { 1,  9,  5,  5, 10,  1,  3, 11,  7,  7,  8,  3,  8,  7,  5,  5,  9,  8,  1, 10, 11, 11,  3,  1, -1}, // 10.1.2
  { 9,  8, 12,  8,  3, 12,  3,  1, 12,  1, 10, 12, 10, 11, 12, 11,  7, 12,  7,  5, 12,  5,  9, 12, -1}, // 10.2 Right
  { 8,  9, 12,  9,  1, 12,  1,  3, 12,  3, 11, 12, 11, 10, 12, 10,  5, 12,  5,  7, 12,  7,  8, 12, -1}, // 10.2 Left

  // Front Right + Back Left
  { 2, 10,  9,  2,  9,  0,  4,  6, 11,  4, 11,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 10.1.1
  { 9,  0,  8,  8,  4,  9, 10,  2, 11, 11,  6, 10,  0,  9, 10, 10,  2,  0,  4,  8, 11, 11,  6,  4, -1}, // 10.1.2
  { 2, 10, 12, 10,  9, 12,  9,  4, 12,  4,  6, 12,  6, 11, 12, 11,  8, 12,  8,  0, 12,  0,  2, 12, -1}, // 10.2 Bottom
  { 2, 12,  0,  0, 12,  9,  9, 12, 10, 10, 12,  6,  6, 12,  4,  4, 12,  8,  8, 12, 11, 11, 12,  2, -1}, // 10.2 Top

  // Bottom Right + Top Left
  { 0,  1,  5,  0,  5,  4,  3,  7,  6,  3,  6,  2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 10.1.1
  { 3,  0,  1,  1,  2,  3,  5,  4,  7,  7,  6,  5,  2,  1,  5,  5,  6,  2,  0,  3,  7,  7,  4,  0, -1}, // 10.1.2
  { 3, 12,  0,  0, 12,  4,  4, 12,  5,  5, 12,  1,  1, 12,  2,  2, 12,  6,  6, 12,  7,  7, 12,  3, -1}, // 10.2 Front
  { 3, 12,  2,  2, 12,  6,  6, 12,  5,  5, 12,  1,  1, 12,  0,  0, 12,  4,  4, 12,  7,  7, 12,  3, -1}, // 10.2 Back

  // Bottom Back + Top Front
  { 1,  3, 11,  1, 11, 10,  7,  8,  9,  7,  9,  5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 10.1.1
  { 1,  9,  5,  5, 10,  1,  3, 11,  7,  7,  8,  3,  3,  8,  9,  9,  1,  3,  7, 11, 10, 10,  5,  7, -1}, // 10.1.2
  { 8, 12,  9,  9, 12,  1,  1, 12,  3,  3, 12, 11, 11, 12, 10, 10, 12,  5,  5, 12,  7,  7, 12,  8, -1}, // 10.2 Right
  { 9, 12,  8,  8, 12,  3,  3, 12,  1,  1, 12, 10, 10, 12, 11, 11, 12,  7,  7, 12,  5,  5, 12,  9, -1}, // 10.2 Left

  // Front Left + Back Right
  { 2,  0,  8,  2,  8, 11,  4,  9, 10,  4, 10,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 10.1.1
  { 9,  0,  8,  8,  4,  9, 10,  2, 11, 11,  6, 10,  2, 11,  8,  8,  0,  2,  9,  4,  6,  6, 10,  9, -1}, // 10.1.2
  { 2,  0, 12,  0,  9, 12,  9, 10, 12, 10,  6, 12,  6,  4, 12,  4,  8, 12,  8, 11, 12, 11,  2, 12, -1}, // 10.2 Bottom
  { 2, 12, 10, 10, 12,  9,  9, 12,  4,  4, 12,  6,  6, 12, 11, 11, 12,  8,  8, 12,  0,  0, 12,  2, -1}, // 10.2 Top
};

// clang-format on

/**
 * @brief Adds a vertex to the vertices list
 * @param vertex  - The vertex to add
 * @return The index of the vertex in the vertices list
 */
static MarchingCubes::IndexType GetVertexIndex(const QVector3D& vertex) {
  MarchingCubes::IndexType nextIndex = vertices->size();
  vertices->push_back(vertex);
  return nextIndex;
}

/**
 * @brief Adds a triangle to the triangle list
 * @param a - index into the vertices list of first  trianlge corner
 * @param b - index into the vertices list of second trianlge corner
 * @param c - index into the vertices list of third  trianlge corner
 */
static void AddTriangle(MarchingCubes::IndexType a, MarchingCubes::IndexType b,
                        MarchingCubes::IndexType c) {
  triangles->push_back({a, b, c});
}

/**
 * @brief   Gets the list of vertices. Is empty before the surface extraction.
 *          Do not change the values inside.
 * @return  A pointer to the list containing the vertices
 */
const QVector<QVector3D>* MarchingCubes::GetVertices() { return vertices; }

/**
 * @brief   Gets the list of triangles. Is empty before the surface extraction.
 *          Do not change the values inside.
 * @return  A pointer to the list containing the triangles
 */
const QVector<MarchingCubes::TRIANGLE>* MarchingCubes::GetTriangles() {
  return triangles;
}

/**
 * @brief   Linearly interpolate the position where an isosurface cuts
 *          an edge between two vertices, each with their own scalar value.
 * @param pos1  - The position of the first corner
 * @param pos2  - The position of the second corner
 * @param val1  - The value of the first corner
 * @param val2  - The value of the second corner
 * @return  The index of the added vertex in the vertices list
 */
static MarchingCubes::IndexType VertexInterp(const QVector3D& pos1,
                                             const QVector3D& pos2,
                                             double valp1, double valp2) {
  if (fabs(valp1) < 0.00001) return GetVertexIndex(pos1);
  if (fabs(valp2) < 0.00001) return GetVertexIndex(pos2);
  if (fabs(valp1 - valp2) < 0.00001) return GetVertexIndex(pos1);

  double mu = (-valp1) / (valp2 - valp1);

  QVector3D p;
  p.setX(pos1.x() + mu * (pos2.x() - pos1.x()));
  p.setY(pos1.y() + mu * (pos2.y() - pos1.y()));
  p.setZ(pos1.z() + mu * (pos2.z() - pos1.z()));

  return GetVertexIndex(p);
}

/**
 * @brief   Interpolates the position of vertex 12 which is in the center of the
 *          voxel.
 * @param   voxel - The voxel in which vertex 12 lies.
 * @return  The index of the added vertex in the vertices list
 */
static MarchingCubes::IndexType Vertex12Interp(const GRIDCELL voxel) {
  /* No interpolation neccessary */
  for (int i = 7; i >= 0; i--)
    if (fabs(voxel.val[i]) < 0.00001) return GetVertexIndex(voxel.pos[i]);

  /* Extraction of the diagonals for the following loops. */
  double diagVal[4][2] = {
      {voxel.val[0], voxel.val[6]},
      {voxel.val[1], voxel.val[7]},
      {voxel.val[5], voxel.val[3]},
      {voxel.val[6], voxel.val[2]},
  };

  QVector3D diagPos[4][2] = {
      {voxel.pos[0], voxel.pos[6]},
      {voxel.pos[1], voxel.pos[7]},
      {voxel.pos[5], voxel.pos[3]},
      {voxel.pos[6], voxel.pos[2]},
  };

  /* No interpolation neccessary */
  for (int i = 3; i >= 0; i--)
    if (fabs(diagVal[i][1] - diagVal[i][0]) < 0.00001)
      return GetVertexIndex(diagPos[i][0]);

  double mu[6];
  /* Calculating the first 4 interpolation factors. */
  for (int i = 3; i >= 0; i--)
    mu[i] = -diagVal[i][0] / (diagVal[i][1] - diagVal[i][0]);

  double valueOnDiag[6];
  QVector3D posOnDiag[6];

  /* Calculation of value and position of the linearly interpolated vertex for
   * each diagonal. */
  for (int i = 3; i >= 0; i--) {
    valueOnDiag[i] = diagVal[i][0] + mu[i] * (diagVal[i][1] - diagVal[i][0]);

    posOnDiag[i].setX(diagPos[i][0].x() +
                      mu[i] * (diagPos[i][1].x() - diagPos[i][0].x()));
    posOnDiag[i].setY(diagPos[i][0].y() +
                      mu[i] * (diagPos[i][1].y() - diagPos[i][0].y()));
    posOnDiag[i].setZ(diagPos[i][0].z() +
                      mu[i] * (diagPos[i][1].z() - diagPos[i][0].z()));

    /* No interpolation neccessary */
    if (fabs(valueOnDiag[i]) < 0.00001) return GetVertexIndex(posOnDiag[i]);
  }

  /* No interpolation neccessary */
  if (fabs(valueOnDiag[0] - valueOnDiag[1]) < 0.00001)
    return GetVertexIndex(posOnDiag[0]);
  if (fabs(valueOnDiag[2] - valueOnDiag[3]) < 0.00001)
    return GetVertexIndex(posOnDiag[2]);

  /* Calculating the next two interpolation factors. */
  mu[4] = -valueOnDiag[0] / (valueOnDiag[1] - valueOnDiag[0]);
  mu[5] = -valueOnDiag[2] / (valueOnDiag[3] - valueOnDiag[2]);

  // TODO: Something is broken here
  // valueOnDiag, posOnDiag and mu do not have an entry [6].
  // Probably the next loop should go over 5/4 instead of 6/5
  // Additionally, valueOnDiag[5] and valueOnDiag[4] are not initialized.
  // Also, "valueOnDiag[i] - valueOnDiag[i]" does not seem to be really useful.
  throw vx::Exception("de.uni_stuttgart.Voxie.MarchingCubes33.TODO",
                      "TODO: Fix this, something is broken here");

  /* Calculation of value and position of the two linearly interpolated vertices
   * between two diagonals. */
  for (int i = 6; i >= 5; i--) {
    valueOnDiag[i] = valueOnDiag[i] + mu[i] * (valueOnDiag[i] - valueOnDiag[i]);

    posOnDiag[i].setX(posOnDiag[i].x() +
                      mu[i] * (posOnDiag[i].x() - posOnDiag[i].x()));
    posOnDiag[i].setY(posOnDiag[i].y() +
                      mu[i] * (posOnDiag[i].y() - posOnDiag[i].y()));
    posOnDiag[i].setZ(posOnDiag[i].z() +
                      mu[i] * (posOnDiag[i].z() - posOnDiag[i].z()));

    /* No interpolation neccessary */
    if (fabs(valueOnDiag[i]) < 0.00001) return GetVertexIndex(posOnDiag[i]);
  }

  /* No interpolation neccessary */
  if (fabs(valueOnDiag[4] - valueOnDiag[5]) < 0.00001)
    return GetVertexIndex(posOnDiag[4]);

  /* Calculating the final interpolation factor. */
  double finalMu = -valueOnDiag[4] / (valueOnDiag[5] - valueOnDiag[4]);

  QVector3D vertex12;

  /* Calculation of the final position of vertex 12 based on the two vertices
   * calculated in the last step. */
  vertex12.setX(posOnDiag[4].x() +
                finalMu * (posOnDiag[4].x() - posOnDiag[5].x()));
  vertex12.setY(posOnDiag[4].y() +
                finalMu * (posOnDiag[4].y() - posOnDiag[5].y()));
  vertex12.setZ(posOnDiag[4].z() +
                finalMu * (posOnDiag[4].z() - posOnDiag[5].z()));

  return GetVertexIndex(vertex12);
}

namespace {
// Caches the vertex indices for all the vertices for 1 plane
//
// This is used to make sure that there are no duplicate vertices in
// the resulting surface
class VertexCache {
  size_t dimX, dimY;
  size_t planeXCount;
  size_t planeYCount;
  size_t planeZCount;
  QVector<MarchingCubes::IndexType> plane1X;
  QVector<MarchingCubes::IndexType> plane1Y;
  QVector<MarchingCubes::IndexType> plane2X;
  QVector<MarchingCubes::IndexType> plane2Y;
  QVector<MarchingCubes::IndexType> planeZ;
  MarchingCubes::IndexType* planeLowX;
  MarchingCubes::IndexType* planeLowY;
  MarchingCubes::IndexType* planeUppX;
  MarchingCubes::IndexType* planeUppY;

 public:
  VertexCache(size_t dimX, size_t dimY)
      : dimX(dimX),
        dimY(dimY),
        planeXCount((dimX + 1) * (dimY + 2)),
        planeYCount((dimX + 2) * (dimY + 1)),
        planeZCount((dimX + 2) * (dimY + 2)),
        plane1X(planeXCount),
        plane1Y(planeYCount),
        plane2X(planeXCount),
        plane2Y(planeYCount),
        planeZ(planeZCount) {
    planeLowX = plane1X.data();
    planeLowY = plane1Y.data();
    planeUppX = plane2X.data();
    planeUppY = plane2Y.data();

    memset(planeUppX, -1, planeXCount * sizeof(MarchingCubes::IndexType));
    memset(planeUppY, -1, planeYCount * sizeof(MarchingCubes::IndexType));
  }

  void nextPlane() {
    std::swap(planeLowX, planeUppX);
    std::swap(planeLowY, planeUppY);
    memset(planeUppX, -1, planeXCount * sizeof(MarchingCubes::IndexType));
    memset(planeUppY, -1, planeYCount * sizeof(MarchingCubes::IndexType));
    memset(planeZ.data(), -1, planeZCount * sizeof(MarchingCubes::IndexType));
  }

  MarchingCubes::IndexType& get(int axis, size_t x, size_t y, size_t z) {
    MarchingCubes::IndexType* ptr;

    size_t sizeX, sizeY;

    switch (axis) {
      case 0:
        ptr = z ? planeUppX : planeLowX;
        sizeX = dimX + 1;
        sizeY = dimY + 2;
        break;

      case 1:
        ptr = z ? planeUppY : planeLowY;
        sizeX = dimX + 2;
        sizeY = dimY + 1;
        break;

      case 2:
        ptr = planeZ.data();
        sizeX = dimX + 2;
        sizeY = dimY + 2;
        break;

      default:
        abort();
    }

    // qDebug() << x << sizeX << y << sizeY << z << axis;
    if (x >= sizeX || y >= sizeY || z >= 2 || (z && axis == 2)) abort();

    return ptr[x + sizeX * y];
  }
};
}  // namespace

/**
 * @brief Tests if a vertex already exists at the "specified" position or
 *        creates a new one if not.
 * @param vertices  - A list of 13 vertex indices. After this method returns
 *                    contains the vertex index into the vertices list of
 *                    vertex "index" at position "index"
 * @param index     - A number from 0 to 12 identifying the relevant of the 13
 *                    possible vertices of a voxel.
 * @param cache     - A cache object used to make sure each vertex exists only
 *                    once
 * @param voxel     - The voxel for which the vertex index is needed
 * @param corner1   - The first corner of the edge of which to get the vertex
 *                    index. Use any value if "index == 12".
 * @param corner2   - The second corner of the edge of which to get the vertex
 *                    index. Use any value if "index == 12".
 */
static void GetVertexIndex(MarchingCubes::IndexType* vertices, int index,
                           VertexCache& cache, const GRIDCELL& voxel,
                           int corner1, int corner2) {
  if (index == 12) {
    vertices[index] = Vertex12Interp(voxel);
  } else {
    static const int axis[12] = {
        0, 2, 0, 2, 0, 2, 0, 2, 1, 1, 1, 1,
    };

    static const int offsets[12][3] = {
        {0 /**/, 0, 1}, {1, 0, 0 /**/}, {0 /**/, 0, 0}, {0, 0, 0 /**/},

        {0 /**/, 1, 1}, {1, 1, 0 /**/}, {0 /**/, 1, 0}, {0, 1, 0 /**/},

        {0, 0 /**/, 1}, {1, 0 /**/, 1}, {1, 0 /**/, 0}, {0, 0 /**/, 0},
    };

    size_t x = voxel.x + offsets[index][0];
    size_t y = voxel.y + offsets[index][1];
    size_t z = offsets[index][2];

    MarchingCubes::IndexType& cacheItem = cache.get(axis[index], x, y, z);
    if (cacheItem != MarchingCubes::invalidVertex) {
      vertices[index] = cacheItem;
      return;
    }

    vertices[index] = cacheItem =
        VertexInterp(voxel.pos[corner1], voxel.pos[corner2], voxel.val[corner1],
                     voxel.val[corner2]);
  }
}

/**
 * @brief Solves the Midnight formula. Returns an array containing the results.
 * @param a - quadratic scalar
 * @param b - linear scalar
 * @param c - constant scalar
 * @return std::array<float, 2>
 *              - containing the results if sqrt argument was >= 0
 *              - containing nan         if sqrt argument was < 0
 */
/*
static std::array<float, 2> SolveQuadraticEquation(float a, float b, float c)
{
  // TODO: Possible to improve performance ?
  float discriminant = b*b - 4.0 * a * c;
  if(discriminant >= 0.0)
  {
    float x1 = (-b + sqrt(discriminant)) / (2.0 * a);
    float x2 = (-b - sqrt(discriminant)) / (2.0 * a);
    std::array<float, 2> results = {x1, x2};
    return results;
  }

  return {nanf(""), nanf("")};
}
*/

/**
 * @brief Resolves the face ambiguity, meaning it decides which corners of the
 *        face are connected across the face. An ambiguity exists if
 *        neighbouring corners are on different sides of the isovalue but
 *        opposite corners are on the same side.
 * @param face - The face to resolve the ambiguity with the isovalue already
 *               substracted from its corners
 * @return 0 - if face.val[0] and face.val[2] are connected
 *         1 - if face.val[1] and face.val[3] are connected
 *        -1 - if it can not be decided
 */
static int ResolveFaceAmbiguity(GRIDCELL& face) {
  double AC = face.val[0] * face.val[2];
  double BD = face.val[1] * face.val[3];
  if (AC > BD)
    return 0;
  else if (AC < BD)
    return 1;
  else
    return -1;
}

/**
 * @brief Resolves the ambiguity inside a voxel, meaning it decides if the
 *        positiv corners are connected or not.
 *
 * The voxel has to have the ambiguous diagonal from corner 0 to corner 6.
 *
 * @param voxel  - The voxel to resolve the ambiguity in with the isovalue
 *                 already substracted from its corners
 * @param offset - The offset of the corner pair to be tested
 * @return AMBIGUITYRESOLVERETURN with the fields:
 *            - connected : false, if corner pair is not connected
 *                        : true, if the corner pair is connected
 *            - a, b, c   : The coefficients of the quadratic equation between
 *                          the corners of the corner pair
 */
static AMBIGUITYRESOLVERETURN ResolveInVoxelAmbiguity(GRIDCELL& voxel) {
  AMBIGUITYRESOLVERETURN result;

  /* For the layout compare Chernyaev's "Marching Cubes 33" */
  double A0 = voxel.val[0];
  double B0 = voxel.val[4];
  double C0 = voxel.val[5];
  double D0 = voxel.val[1];
  double A1 = voxel.val[3];
  double B1 = voxel.val[7];
  double C1 = voxel.val[6];
  double D1 = voxel.val[2];

  double a = (A1 - A0) * (C1 - C0) - (B1 - B0) * (D1 - D0);
  if (a >= 0) return result;  // If true, not connected
  double b = C0 * (A1 - A0) + A0 * (C1 - C0) - D0 * (B1 - B0) - B0 * (D1 - D0);
  double c = A0 * C0 - B0 * D0;

  double tMax = (-1) * b / (2 * a);
  // Cutting Plane not inside voxel => A0 and C1 not connected inside the voxel
  if (tMax <= 0 || tMax >= 1) return result;

  // Corners of cutting plane
  double At = A0 + (A1 - A0) * tMax;
  double Ct = C0 + (C1 - C0) * tMax;

  if ((std::signbit(At) == std::signbit(Ct)) &&
      (std::signbit(At) == std::signbit(A0)))
    if (a * tMax * tMax + b * tMax + c > 0) {
      // A0 and C1 are connected inside the voxel (except for case 13.5.1/2)
      result.connected = true;
      result.a = a;
      result.b = b;
      result.c = c;
    }

  return result;  // A0 and C1 are not connected inside the voxel
}

/**
 * @brief Creates the Marching Cubes surface defined by its parameters
 *
 * @param voxel           - The voxel to create a surface of
 * @param triangles       - Array containing TRIANGLEs. Contains the correct
 *                          triangles after this method returns.
 * @param triangleLabels  - Array containing TRIANGLELABELs. Contains which
 *                          side of the TRIANGLE is facing outwards, which
 *                          inwards.
 * @param cache           - A cache to make sure every vertex exists only once.
 * @param edgeTableEntry  - Entry of an edge table. Defines vertex positions.
 * @param triTableEntry   - Entry of a tri table. Defines triangles as
 *                          connected vertices.
 * @param cubeindex       - The index into the edge and tri tables.
 *
 * @return                - The number of creted TRIANGLEs. Use this to
 *                          determine how many entries of the triangles
 *                          parameter to consider.
 */
static int CreateSurfaceInVoxel(const GRIDCELL& voxel,
                                MarchingCubes::TRIANGLE* triangles,
                                TRIANGLELABEL* triangleLabels,
                                VertexCache& cache, const int edgeTableEntry,
                                const int triTableEntry[]) {
  int i = 0;
  int ntriang = 0;
  MarchingCubes::IndexType vertlist[13];

  /* Find the vertices where the surface intersects the cube */
  if (edgeTableEntry & 1) GetVertexIndex(vertlist, 0, cache, voxel, 0, 1);
  if (edgeTableEntry & 2) GetVertexIndex(vertlist, 1, cache, voxel, 1, 2);
  if (edgeTableEntry & 4) GetVertexIndex(vertlist, 2, cache, voxel, 2, 3);
  if (edgeTableEntry & 8) GetVertexIndex(vertlist, 3, cache, voxel, 3, 0);
  if (edgeTableEntry & 16) GetVertexIndex(vertlist, 4, cache, voxel, 4, 5);
  if (edgeTableEntry & 32) GetVertexIndex(vertlist, 5, cache, voxel, 5, 6);
  if (edgeTableEntry & 64) GetVertexIndex(vertlist, 6, cache, voxel, 6, 7);
  if (edgeTableEntry & 128) GetVertexIndex(vertlist, 7, cache, voxel, 7, 4);
  if (edgeTableEntry & 256) GetVertexIndex(vertlist, 8, cache, voxel, 0, 4);
  if (edgeTableEntry & 512) GetVertexIndex(vertlist, 9, cache, voxel, 1, 5);
  if (edgeTableEntry & 1024) GetVertexIndex(vertlist, 10, cache, voxel, 2, 6);
  if (edgeTableEntry & 2048) GetVertexIndex(vertlist, 11, cache, voxel, 3, 7);
  if (edgeTableEntry & 4096) GetVertexIndex(vertlist, 12, cache, voxel, -1, -1);

  static const int label[][2] = {
      {0, 1}, {1, 2}, {2, 3}, {3, 0}, {4, 5}, {5, 6},
      {6, 7}, {7, 4}, {0, 4}, {1, 5}, {2, 6}, {3, 7},
  };

  /* Create the triangles */
  while (triTableEntry[i] != -1) {
    triangles[ntriang].indices[0] = vertlist[triTableEntry[i]];
    triangles[ntriang].indices[1] = vertlist[triTableEntry[i + 1]];
    triangles[ntriang].indices[2] = vertlist[triTableEntry[i + 2]];

    /* Use this code to identify the offending triTable entry in case a invalid
     * vertex exception is thrown. */
    //    int numberBiggerThanNumberOfVertices = 500000;
    //    if(triangles[ntriang].i[0] > numberBiggerThanNumberOfVertices ||
    //       triangles[ntriang].i[1] > numberBiggerThanNumberOfVertices ||
    //       triangles[ntriang].i[2] > numberBiggerThanNumberOfVertices)
    //    {
    //      int dummy = 9;
    //      int dummy2 = dummy + 1;
    //    }

    auto inside = (voxel.val[label[triTableEntry[i]][0]] < 0) ? 1 : 0;
    triangleLabels[ntriang].inside = label[triTableEntry[i]][inside];
    triangleLabels[ntriang].outside = label[triTableEntry[i]][1 - inside];

    ntriang++;
    i += 3;
  }

  return ntriang;
}

/**
 * @brief Rotates a voxel so the first diagonal on the first diagonal.
 *
 * Returns a voxel which can be used in ResolveInVoxelAmbiguity(). In this case
 * it returns the voxel itself.
 *
 * @param voxel - The voxel to rotate
 *
 * @return Rotated voxel
 */
inline GRIDCELL SetVoxelValuesByFirstDiagonal(const GRIDCELL& voxel) {
  return voxel;
}

/**
 * @brief Rotates a voxel so the second diagonal on the first diagonal.
 *
 * Returns a voxel which can be used in ResolveInVoxelAmbiguity().
 *
 * @param voxel - The voxel to rotate
 *
 * @return Rotated voxel
 */
static GRIDCELL SetVoxelValuesBySecondDiagonal(const GRIDCELL& voxel) {
  GRIDCELL workingVoxel = voxel;
  workingVoxel.val[0] = voxel.val[1];
  workingVoxel.val[1] = voxel.val[5];
  workingVoxel.val[2] = voxel.val[6];
  workingVoxel.val[3] = voxel.val[2];
  workingVoxel.val[4] = voxel.val[0];
  workingVoxel.val[5] = voxel.val[4];
  workingVoxel.val[6] = voxel.val[7];
  workingVoxel.val[7] = voxel.val[3];
  return workingVoxel;
}

/**
 * @brief Rotates a voxel so the third diagonal on the first diagonal.
 *
 * Returns a voxel which can be used in ResolveInVoxelAmbiguity().
 *
 * @param voxel - The voxel to rotate
 *
 * @return Rotated voxel
 */
static GRIDCELL SetVoxelValuesByThirdDiagonal(const GRIDCELL& voxel) {
  GRIDCELL workingVoxel = voxel;
  workingVoxel.val[0] = voxel.val[5];
  workingVoxel.val[1] = voxel.val[4];
  workingVoxel.val[2] = voxel.val[7];
  workingVoxel.val[3] = voxel.val[6];
  workingVoxel.val[4] = voxel.val[1];
  workingVoxel.val[5] = voxel.val[0];
  workingVoxel.val[6] = voxel.val[3];
  workingVoxel.val[7] = voxel.val[2];
  return workingVoxel;
}

/**
 * @brief Rotates a voxel so the fourth diagonal on the first diagonal.
 *
 * Returns a voxel which can be used in ResolveInVoxelAmbiguity().
 *
 * @param voxel - The voxel to rotate
 *
 * @return Rotated voxel
 */
static GRIDCELL SetVoxelValuesByFourthDiagonal(const GRIDCELL& voxel) {
  GRIDCELL workingVoxel = voxel;
  workingVoxel.val[0] = voxel.val[4];
  workingVoxel.val[1] = voxel.val[0];
  workingVoxel.val[2] = voxel.val[3];
  workingVoxel.val[3] = voxel.val[7];
  workingVoxel.val[4] = voxel.val[5];
  workingVoxel.val[5] = voxel.val[1];
  workingVoxel.val[6] = voxel.val[2];
  workingVoxel.val[7] = voxel.val[6];
  return workingVoxel;
}

/**
 * @brief Decides which of the 2 subcases of case 3 is present and
 *        creates the corresponding surface.
 *
 * If the positive and negative nodes of the ambiguous face multiplied together
 * have the exact same value the ambiguity is not resolvable and this method
 * defaults to subcase 3.1.
 * TODO: While this is unlikely to occur in real data it should still be fixed.
 *
 * @param voxel           - The voxel to create a surface of
 * @param triangles       - Array containing 5 TRIANGLEs. Contains the correct
 *                          triangles after this method returns.
 * @param triangleLabels  - Array containing 5 TRIANGLELABELs. Contains which
 *                          side of the TRIANGLE is facing outwards, which
 *                          inwards.
 * @param cache           - A cache to make sure every vertex exists only once.
 * @param cubeindex       - The index into the edge and tri tables.
 *
 * @return                - The number of creted TRIANGLEs. Use this to
 *                          determine how many entries of the triangles
 *                          parameter to consider.
 */
static int ResolveCase3(const GRIDCELL& voxel, int cubeIndex,
                        MarchingCubes::TRIANGLE* triangles,
                        TRIANGLELABEL* triangleLabels, VertexCache& cache) {
  GRIDCELL face;
  int indexOffset; /* The index into triTableCase3. */

  /* The voxel can be in 24 different configurations with 12 of them being the
   * inverse of the other 12.
   * The switch extracts the ambiguos face accordingly. */
  switch (cubeIndex) {
    // Bottom face
    case 0x21:
    case 0xde:
      face.val[0] = voxel.val[0];
      face.val[1] = voxel.val[1];
      face.val[2] = voxel.val[5];
      face.val[3] = voxel.val[4];
      if (cubeIndex == 0x21)
        indexOffset = 0;
      else
        indexOffset = 2;
      break;
    case 0x12:
    case 0xed:
      face.val[0] = voxel.val[1];
      face.val[1] = voxel.val[5];
      face.val[2] = voxel.val[4];
      face.val[3] = voxel.val[0];
      if (cubeIndex == 0x12)
        indexOffset = 4;
      else
        indexOffset = 6;
      break;

    // Top face
    case 0x48:
    case 0xb7:
      face.val[0] = voxel.val[3];
      face.val[1] = voxel.val[7];
      face.val[2] = voxel.val[6];
      face.val[3] = voxel.val[2];
      if (cubeIndex == 0x48)
        indexOffset = 8;
      else
        indexOffset = 10;
      break;
    case 0x84:
    case 0x7b:
      face.val[0] = voxel.val[2];
      face.val[1] = voxel.val[3];
      face.val[2] = voxel.val[7];
      face.val[3] = voxel.val[6];
      if (cubeIndex == 0x84)
        indexOffset = 12;
      else
        indexOffset = 14;
      break;

    // Front face
    case 0x5:
    case 0xfa:
      face.val[0] = voxel.val[0];
      face.val[1] = voxel.val[3];
      face.val[2] = voxel.val[2];
      face.val[3] = voxel.val[1];
      if (cubeIndex == 0x5)
        indexOffset = 16;
      else
        indexOffset = 18;
      break;
    case 0xa:
    case 0xf5:
      face.val[0] = voxel.val[1];
      face.val[1] = voxel.val[2];
      face.val[2] = voxel.val[3];
      face.val[3] = voxel.val[0];
      if (cubeIndex == 0xa)
        indexOffset = 20;
      else
        indexOffset = 22;
      break;

    // Right face
    case 0x42:
    case 0xbd:
      face.val[0] = voxel.val[1];
      face.val[1] = voxel.val[2];
      face.val[2] = voxel.val[6];
      face.val[3] = voxel.val[5];
      if (cubeIndex == 0x42)
        indexOffset = 24;
      else
        indexOffset = 26;
      break;
    case 0x24:
    case 0xdb:
      face.val[0] = voxel.val[2];
      face.val[1] = voxel.val[6];
      face.val[2] = voxel.val[5];
      face.val[3] = voxel.val[1];
      if (cubeIndex == 0x24)
        indexOffset = 28;
      else
        indexOffset = 30;
      break;

    // Back face
    case 0xa0:
    case 0x5f:
      face.val[0] = voxel.val[5];
      face.val[1] = voxel.val[6];
      face.val[2] = voxel.val[7];
      face.val[3] = voxel.val[4];
      if (cubeIndex == 0xa0)
        indexOffset = 32;
      else
        indexOffset = 34;
      break;
    case 0x50:
    case 0xaf:
      face.val[0] = voxel.val[4];
      face.val[1] = voxel.val[5];
      face.val[2] = voxel.val[6];
      face.val[3] = voxel.val[7];
      if (cubeIndex == 0x50)
        indexOffset = 36;
      else
        indexOffset = 38;
      break;

    // Left face
    case 0x18:
    case 0xe7:
      face.val[0] = voxel.val[3];
      face.val[1] = voxel.val[0];
      face.val[2] = voxel.val[4];
      face.val[3] = voxel.val[7];
      if (cubeIndex == 0x18)
        indexOffset = 40;
      else
        indexOffset = 42;
      break;
    case 0x81:
    case 0x7e:
      face.val[0] = voxel.val[0];
      face.val[1] = voxel.val[4];
      face.val[2] = voxel.val[7];
      face.val[3] = voxel.val[3];
      if (cubeIndex == 0x81)
        indexOffset = 44;
      else
        indexOffset = 46;
      break;

    default:
      return 0;
      break;
  }  // switch

  int ambiguityResolved = ResolveFaceAmbiguity(face);
  if (ambiguityResolved == -1) ambiguityResolved = 0;
  indexOffset += ambiguityResolved; /* either 0 or 1*/
  return CreateSurfaceInVoxel(voxel, triangles, triangleLabels, cache,
                              edgeTable[cubeIndex], triTableCase3[indexOffset]);
}

/**
 * @brief Decides which of the 2 subcases of case 4 is present and
 *        creates the corresponding surface.
 *
 * @param voxel           - The voxel to create a surface of
 * @param triangles       - Array containing 6 TRIANGLEs. Contains the correct
 *                          triangles after this method returns.
 * @param triangleLabels  - Array containing 6 TRIANGLELABELs. Contains which
 *                          side of the TRIANGLE is facing outwards, which
 *                          inwards.
 * @param cache           - A cache to make sure every vertex exists only once.
 * @param cubeindex       - The index into the edge and tri tables.
 *
 * @return                - The number of creted TRIANGLEs. Use this to
 *                          determine how many entries of the triangles
 *                          parameter to consider.
 */
static int ResolveCase4(const GRIDCELL& voxel, int cubeIndex,
                        MarchingCubes::TRIANGLE* triangles,
                        TRIANGLELABEL* triangleLabels, VertexCache& cache) {
  GRIDCELL workingVoxel;
  int indexOffset; /* The index into triTableCase4. */

  /* The voxel can be in 8 different configurations with 4 of them being the
   * inverse of the other 4. */
  switch (cubeIndex) {
    // First Diagonal
    case 0x41:
    case 0xbe:
      workingVoxel.val[0] = voxel.val[0];
      workingVoxel.val[1] = voxel.val[1];
      workingVoxel.val[2] = voxel.val[2];
      workingVoxel.val[3] = voxel.val[3];
      workingVoxel.val[4] = voxel.val[4];
      workingVoxel.val[5] = voxel.val[5];
      workingVoxel.val[6] = voxel.val[6];
      workingVoxel.val[7] = voxel.val[7];
      if (cubeIndex == 0x41)
        indexOffset = 0;
      else
        indexOffset = 2;
      break;

    // Second Diagonal
    case 0x82:
    case 0x7d:
      workingVoxel.val[0] = voxel.val[1];
      workingVoxel.val[1] = voxel.val[5];
      workingVoxel.val[2] = voxel.val[6];
      workingVoxel.val[3] = voxel.val[2];
      workingVoxel.val[4] = voxel.val[0];
      workingVoxel.val[5] = voxel.val[4];
      workingVoxel.val[6] = voxel.val[7];
      workingVoxel.val[7] = voxel.val[3];
      if (cubeIndex == 0x82)
        indexOffset = 4;
      else
        indexOffset = 6;
      break;

    // Third Diagonal
    case 0x28:
    case 0xd7:
      workingVoxel.val[0] = voxel.val[5];
      workingVoxel.val[1] = voxel.val[4];
      workingVoxel.val[2] = voxel.val[7];
      workingVoxel.val[3] = voxel.val[6];
      workingVoxel.val[4] = voxel.val[1];
      workingVoxel.val[5] = voxel.val[0];
      workingVoxel.val[6] = voxel.val[3];
      workingVoxel.val[7] = voxel.val[2];
      if (cubeIndex == 0x28)
        indexOffset = 8;
      else
        indexOffset = 10;
      break;

    // Fourth Diagonal
    case 0x14:
    case 0xeb:
      workingVoxel.val[0] = voxel.val[4];
      workingVoxel.val[1] = voxel.val[0];
      workingVoxel.val[2] = voxel.val[3];
      workingVoxel.val[3] = voxel.val[7];
      workingVoxel.val[4] = voxel.val[5];
      workingVoxel.val[5] = voxel.val[1];
      workingVoxel.val[6] = voxel.val[2];
      workingVoxel.val[7] = voxel.val[6];
      if (cubeIndex == 0x14)
        indexOffset = 12;
      else
        indexOffset = 14;
      break;

    default:
      return 0;
      break;
  }  // switch

  AMBIGUITYRESOLVERETURN ambiguityResolved =
      ResolveInVoxelAmbiguity(workingVoxel);
  indexOffset += ambiguityResolved.connected; /* either 0 or 1*/
  return CreateSurfaceInVoxel(voxel, triangles, triangleLabels, cache,
                              edgeTable[cubeIndex], triTableCase4[indexOffset]);
}

/**
 * @brief Decides which of the 3 subcases of case 6 is present.
 *
 * If the positive and negative nodes of the ambiguous face multiplied together
 * have the exact same value the ambiguity is not resolvable and this method
 * defaults to subcase 6.1.1.
 * TODO: While this is unlikely to occur in real data it should still be fixed.
 *
 * @param voxel           - The voxel to create a surface of
 * @param triangles       - Array containing 6 TRIANGLEs. Contains the correct
 *                          triangles after this method returns.
 * @param triangleLabels  - Array containing 6 TRIANGLELABELs. Contains which
 *                          side of the TRIANGLE is facing outwards, which
 *                          inwards.
 * @param cache           - A cache to make sure every vertex exists only once.
 * @param cubeindex       - The index into the edge and tri tables.
 *
 * @return                - The number of creted TRIANGLEs. Use this to
 *                          determine how many entries of the triangles
 *                          parameter to consider.
 */
static int ResolveCase6(const GRIDCELL& voxel, int cubeIndex,
                        MarchingCubes::TRIANGLE* triangles,
                        TRIANGLELABEL* triangleLabels, VertexCache& cache) {
  GRIDCELL face;
  GRIDCELL workingVoxel;
  int indexOffset; /* The index into triTableCase3. */

  /* The voxel can be in 24 different configurations.
   * The switch extracts the ambiguos face accordingly. */
  switch (cubeIndex) {
    // Front Bottom + Left
    case 0x83:
    case 0x7c:
      face.val[0] = voxel.val[0];
      face.val[1] = voxel.val[3];
      face.val[2] = voxel.val[7];
      face.val[3] = voxel.val[4];
      workingVoxel = SetVoxelValuesBySecondDiagonal(voxel);
      if (cubeIndex == 0x83)
        indexOffset = 0;
      else
        indexOffset = 3;
      break;
    // Front Bottom + Right
    case 0x43:
    case 0xbc:
      face.val[0] = voxel.val[1];
      face.val[1] = voxel.val[5];
      face.val[2] = voxel.val[6];
      face.val[3] = voxel.val[2];
      workingVoxel = SetVoxelValuesByFirstDiagonal(voxel);
      if (cubeIndex == 0x43)
        indexOffset = 6;
      else
        indexOffset = 9;
      break;

    // Front Right + Bottom
    case 0x16:
    case 0xe9:
      face.val[0] = voxel.val[1];
      face.val[1] = voxel.val[0];
      face.val[2] = voxel.val[4];
      face.val[3] = voxel.val[5];
      workingVoxel = SetVoxelValuesByFourthDiagonal(voxel);
      if (cubeIndex == 0x16)
        indexOffset = 12;
      else
        indexOffset = 15;
      break;
    // Front Right + Top
    case 0x86:
    case 0x79:
      face.val[0] = voxel.val[2];
      face.val[1] = voxel.val[6];
      face.val[2] = voxel.val[7];
      face.val[3] = voxel.val[3];
      workingVoxel = SetVoxelValuesBySecondDiagonal(voxel);
      if (cubeIndex == 0x86)
        indexOffset = 18;
      else
        indexOffset = 21;
      break;

    // Front Top + Right
    case 0x2c:
    case 0xd3:
      face.val[0] = voxel.val[2];
      face.val[1] = voxel.val[1];
      face.val[2] = voxel.val[5];
      face.val[3] = voxel.val[6];
      workingVoxel = SetVoxelValuesByThirdDiagonal(voxel);
      if (cubeIndex == 0x2c)
        indexOffset = 24;
      else
        indexOffset = 27;
      break;
    // Front Top + Left
    case 0x1c:
    case 0xe3:
      face.val[0] = voxel.val[3];
      face.val[1] = voxel.val[7];
      face.val[2] = voxel.val[4];
      face.val[3] = voxel.val[0];
      workingVoxel = SetVoxelValuesByFourthDiagonal(voxel);
      if (cubeIndex == 0x1c)
        indexOffset = 30;
      else
        indexOffset = 33;
      break;

    // Front Left + Top
    case 0x49:
    case 0xb6:
      face.val[0] = voxel.val[3];
      face.val[1] = voxel.val[2];
      face.val[2] = voxel.val[6];
      face.val[3] = voxel.val[7];
      workingVoxel = SetVoxelValuesByFirstDiagonal(voxel);
      if (cubeIndex == 0x49)
        indexOffset = 36;
      else
        indexOffset = 39;
      break;
    // Front Left + Bottom
    case 0x29:
    case 0xd6:
      face.val[0] = voxel.val[0];
      face.val[1] = voxel.val[1];
      face.val[2] = voxel.val[5];
      face.val[3] = voxel.val[4];
      workingVoxel = SetVoxelValuesByThirdDiagonal(voxel);
      if (cubeIndex == 0x29)
        indexOffset = 42;
      else
        indexOffset = 45;
      break;

    // Back Bottom + Left
    case 0x38:
    case 0xc7:
      face.val[0] = voxel.val[4];
      face.val[1] = voxel.val[7];
      face.val[2] = voxel.val[3];
      face.val[3] = voxel.val[0];
      workingVoxel = SetVoxelValuesByThirdDiagonal(voxel);
      if (cubeIndex == 0x38)
        indexOffset = 48;
      else
        indexOffset = 51;
      break;
    // Back Bottom + Right
    case 0x34:
    case 0xcb:
      face.val[0] = voxel.val[5];
      face.val[1] = voxel.val[6];
      face.val[2] = voxel.val[2];
      face.val[3] = voxel.val[1];
      workingVoxel = SetVoxelValuesByFourthDiagonal(voxel);
      if (cubeIndex == 0x34)
        indexOffset = 54;
      else
        indexOffset = 57;
      break;

    // Back Right + Bottom
    case 0x61:
    case 0x9e:
      face.val[0] = voxel.val[5];
      face.val[1] = voxel.val[4];
      face.val[2] = voxel.val[0];
      face.val[3] = voxel.val[1];
      workingVoxel = SetVoxelValuesByFirstDiagonal(voxel);
      if (cubeIndex == 0x61)
        indexOffset = 60;
      else
        indexOffset = 63;
      break;
    // Back Right + Top
    case 0x68:
    case 0x97:
      face.val[0] = voxel.val[6];
      face.val[1] = voxel.val[7];
      face.val[2] = voxel.val[3];
      face.val[3] = voxel.val[2];
      workingVoxel = SetVoxelValuesByThirdDiagonal(voxel);
      if (cubeIndex == 0x68)
        indexOffset = 66;
      else
        indexOffset = 69;
      break;

    // Back Top + Right
    case 0xc2:
    case 0x3d:
      face.val[0] = voxel.val[6];
      face.val[1] = voxel.val[2];
      face.val[2] = voxel.val[1];
      face.val[3] = voxel.val[5];
      workingVoxel = SetVoxelValuesBySecondDiagonal(voxel);
      if (cubeIndex == 0xc2)
        indexOffset = 72;
      else
        indexOffset = 75;
      break;
    // Back Top + Left
    case 0xc1:
    case 0x3e:
      face.val[0] = voxel.val[7];
      face.val[1] = voxel.val[3];
      face.val[2] = voxel.val[0];
      face.val[3] = voxel.val[4];
      workingVoxel = SetVoxelValuesByFirstDiagonal(voxel);
      if (cubeIndex == 0xc1)
        indexOffset = 78;
      else
        indexOffset = 81;
      break;

    // Back Left + Top
    case 0x94:
    case 0x6b:
      face.val[0] = voxel.val[7];
      face.val[1] = voxel.val[3];
      face.val[2] = voxel.val[2];
      face.val[3] = voxel.val[6];
      workingVoxel = SetVoxelValuesByFourthDiagonal(voxel);
      if (cubeIndex == 0x94)
        indexOffset = 84;
      else
        indexOffset = 87;
      break;
    // Back Left + Bottom
    case 0x92:
    case 0x6d:
      face.val[0] = voxel.val[4];
      face.val[1] = voxel.val[0];
      face.val[2] = voxel.val[1];
      face.val[3] = voxel.val[5];
      workingVoxel = SetVoxelValuesBySecondDiagonal(voxel);
      if (cubeIndex == 0x92)
        indexOffset = 90;
      else
        indexOffset = 93;
      break;

    // Left Bottom + Front
    case 0x15:
    case 0xea:
      face.val[0] = voxel.val[0];
      face.val[1] = voxel.val[1];
      face.val[2] = voxel.val[2];
      face.val[3] = voxel.val[3];
      workingVoxel = SetVoxelValuesByFourthDiagonal(voxel);
      if (cubeIndex == 0x15)
        indexOffset = 96;
      else
        indexOffset = 99;
      break;
    // Left Bottom + Back
    case 0x51:
    case 0xae:
      face.val[0] = voxel.val[4];
      face.val[1] = voxel.val[5];
      face.val[2] = voxel.val[6];
      face.val[3] = voxel.val[7];
      workingVoxel = SetVoxelValuesByFirstDiagonal(voxel);
      if (cubeIndex == 0x51)
        indexOffset = 102;
      else
        indexOffset = 105;
      break;

    // Right Bottom + Front
    case 0x2a:
    case 0xd5:
      face.val[0] = voxel.val[1];
      face.val[1] = voxel.val[2];
      face.val[2] = voxel.val[3];
      face.val[3] = voxel.val[0];
      workingVoxel = SetVoxelValuesByThirdDiagonal(voxel);
      if (cubeIndex == 0x2a)
        indexOffset = 108;
      else
        indexOffset = 111;
      break;
    // Right Bottom + Back
    case 0xa2:
    case 0x5d:
      face.val[0] = voxel.val[5];
      face.val[1] = voxel.val[6];
      face.val[2] = voxel.val[7];
      face.val[3] = voxel.val[4];
      workingVoxel = SetVoxelValuesBySecondDiagonal(voxel);
      if (cubeIndex == 0xa2)
        indexOffset = 114;
      else
        indexOffset = 117;
      break;

    // Right Top + Front
    case 0x45:
    case 0xba:
      face.val[0] = voxel.val[2];
      face.val[1] = voxel.val[3];
      face.val[2] = voxel.val[0];
      face.val[3] = voxel.val[1];
      workingVoxel = SetVoxelValuesByFirstDiagonal(voxel);
      if (cubeIndex == 0x45)
        indexOffset = 120;
      else
        indexOffset = 123;
      break;
    // Right Top + Back
    case 0x54:
    case 0xab:
      face.val[0] = voxel.val[6];
      face.val[1] = voxel.val[7];
      face.val[2] = voxel.val[4];
      face.val[3] = voxel.val[5];
      workingVoxel = SetVoxelValuesByFourthDiagonal(voxel);
      if (cubeIndex == 0x54)
        indexOffset = 126;
      else
        indexOffset = 129;
      break;

    // Left Top + Front
    case 0x8a:
    case 0x75:
      face.val[0] = voxel.val[3];
      face.val[1] = voxel.val[0];
      face.val[2] = voxel.val[1];
      face.val[3] = voxel.val[2];
      workingVoxel = SetVoxelValuesBySecondDiagonal(voxel);
      if (cubeIndex == 0x8a)
        indexOffset = 132;
      else
        indexOffset = 135;
      break;
    // Left Top + Back
    case 0xa8:
    case 0x57:
      face.val[0] = voxel.val[7];
      face.val[1] = voxel.val[4];
      face.val[2] = voxel.val[5];
      face.val[3] = voxel.val[6];
      workingVoxel = SetVoxelValuesByThirdDiagonal(voxel);
      if (cubeIndex == 0xa8)
        indexOffset = 138;
      else
        indexOffset = 141;
      break;

    default:
      return 0;
      break;
  }  // switch

  int faceAmbiguityResolved = ResolveFaceAmbiguity(face);
  if (faceAmbiguityResolved == 1) {
    AMBIGUITYRESOLVERETURN ambiguityResolved;
    ambiguityResolved = ResolveInVoxelAmbiguity(workingVoxel);
    if (ambiguityResolved.connected) indexOffset += 1;
  } else if (faceAmbiguityResolved == 0)
    indexOffset += 2;
  return CreateSurfaceInVoxel(voxel, triangles, triangleLabels, cache,
                              edgeTable[cubeIndex], triTableCase6[indexOffset]);
}

/**
 * @brief Decides which of the 5 (+4) subcases of case 7 is present and
 *        creates the corresponding surface.
 *
 * If the positive and negative nodes of the ambiguous face multiplied together
 * have the exact same value the face ambiguity is not resolvable and this
 * method defaults to subcase 7.1.
 * TODO: While this is unlikely to occur in real data it should still be fixed.
 *
 * @param voxel           - The voxel to create a surface of
 * @param triangles       - Array containing 9 TRIANGLEs. Contains the correct
 *                          triangles after this method returns.
 * @param triangleLabels  - Array containing 9 TRIANGLELABELs. Contains which
 *                          side of the TRIANGLE is facing outwards, which
 *                          inwards.
 * @param cache           - A cache to make sure every vertex exists only once.
 * @param cubeindex       - The index into the edge and tri tables.
 *
 * @return                - The number of creted TRIANGLEs. Use this to
 *                          determine how many entries of the triangles
 *                          parameter to consider.
 */
static int ResolveCase7(const GRIDCELL& voxel, int cubeIndex,
                        MarchingCubes::TRIANGLE* triangles,
                        TRIANGLELABEL* triangleLabels, VertexCache& cache) {
  GRIDCELL face1;
  GRIDCELL face2;
  GRIDCELL face3;
  GRIDCELL workingVoxel;
  int indexOffset;

  switch (cubeIndex) {
    // Front Top Right
    case 0x4a:
    case 0xb5:
      face1.val[0] = voxel.val[1];
      face1.val[1] = voxel.val[2];
      face1.val[2] = voxel.val[3];
      face1.val[3] = voxel.val[0];
      face2.val[0] = voxel.val[3];
      face2.val[1] = voxel.val[7];
      face2.val[2] = voxel.val[6];
      face2.val[3] = voxel.val[2];
      face3.val[0] = voxel.val[1];
      face3.val[1] = voxel.val[5];
      face3.val[2] = voxel.val[6];
      face3.val[3] = voxel.val[2];
      workingVoxel = SetVoxelValuesByFourthDiagonal(voxel);
      if (cubeIndex == 0x4a)
        indexOffset = 7;
      else
        indexOffset = 16;
      break;
    // Back Top Right
    case 0xa4:
    case 0x5b:
      face1.val[0] = voxel.val[2];
      face1.val[1] = voxel.val[1];
      face1.val[2] = voxel.val[5];
      face1.val[3] = voxel.val[6];
      face2.val[0] = voxel.val[2];
      face2.val[1] = voxel.val[6];
      face2.val[2] = voxel.val[7];
      face2.val[3] = voxel.val[3];
      face3.val[0] = voxel.val[5];
      face3.val[1] = voxel.val[4];
      face3.val[2] = voxel.val[7];
      face3.val[3] = voxel.val[6];
      workingVoxel = SetVoxelValuesByFirstDiagonal(voxel);
      if (cubeIndex == 0xa4)
        indexOffset = 25;
      else
        indexOffset = 34;
      break;
    // Back Top Left
    case 0x58:
    case 0xa7:
      face1.val[0] = voxel.val[4];
      face1.val[1] = voxel.val[5];
      face1.val[2] = voxel.val[6];
      face1.val[3] = voxel.val[7];
      face2.val[0] = voxel.val[3];
      face2.val[1] = voxel.val[7];
      face2.val[2] = voxel.val[6];
      face2.val[3] = voxel.val[2];
      face3.val[0] = voxel.val[3];
      face3.val[1] = voxel.val[7];
      face3.val[2] = voxel.val[4];
      face3.val[3] = voxel.val[0];
      workingVoxel = SetVoxelValuesBySecondDiagonal(voxel);
      if (cubeIndex == 0x58)
        indexOffset = 43;
      else
        indexOffset = 52;
      break;
    // Front Top Left
    case 0x85:
    case 0x7a:
      face1.val[0] = voxel.val[0];
      face1.val[1] = voxel.val[3];
      face1.val[2] = voxel.val[7];
      face1.val[3] = voxel.val[4];
      face2.val[0] = voxel.val[2];
      face2.val[1] = voxel.val[6];
      face2.val[2] = voxel.val[7];
      face2.val[3] = voxel.val[3];
      face3.val[0] = voxel.val[0];
      face3.val[1] = voxel.val[1];
      face3.val[2] = voxel.val[2];
      face3.val[3] = voxel.val[3];
      workingVoxel = SetVoxelValuesByThirdDiagonal(voxel);
      if (cubeIndex == 0x85)
        indexOffset = 61;
      else
        indexOffset = 70;
      break;
    // Front Bottom Right
    case 0x25:
    case 0xda:
      face1.val[0] = voxel.val[2];
      face1.val[1] = voxel.val[6];
      face1.val[2] = voxel.val[5];
      face1.val[3] = voxel.val[1];
      face2.val[0] = voxel.val[0];
      face2.val[1] = voxel.val[1];
      face2.val[2] = voxel.val[5];
      face2.val[3] = voxel.val[4];
      face3.val[0] = voxel.val[0];
      face3.val[1] = voxel.val[1];
      face3.val[2] = voxel.val[2];
      face3.val[3] = voxel.val[3];
      workingVoxel = SetVoxelValuesBySecondDiagonal(voxel);
      if (cubeIndex == 0x25)
        indexOffset = 79;
      else
        indexOffset = 88;
      break;
    // Back Bottom Right
    case 0x52:
    case 0xad:
      face1.val[0] = voxel.val[4];
      face1.val[1] = voxel.val[5];
      face1.val[2] = voxel.val[6];
      face1.val[3] = voxel.val[7];
      face2.val[0] = voxel.val[1];
      face2.val[1] = voxel.val[5];
      face2.val[2] = voxel.val[4];
      face2.val[3] = voxel.val[0];
      face3.val[0] = voxel.val[1];
      face3.val[1] = voxel.val[5];
      face3.val[2] = voxel.val[6];
      face3.val[3] = voxel.val[2];
      workingVoxel = SetVoxelValuesByThirdDiagonal(voxel);
      if (cubeIndex == 0x52)
        indexOffset = 97;
      else
        indexOffset = 106;
      break;
    // Back Bottom Left
    case 0xa1:
    case 0x5e:
      face1.val[0] = voxel.val[0];
      face1.val[1] = voxel.val[4];
      face1.val[2] = voxel.val[7];
      face1.val[3] = voxel.val[3];
      face2.val[0] = voxel.val[0];
      face2.val[1] = voxel.val[1];
      face2.val[2] = voxel.val[5];
      face2.val[3] = voxel.val[4];
      face3.val[0] = voxel.val[5];
      face3.val[1] = voxel.val[4];
      face3.val[2] = voxel.val[7];
      face3.val[3] = voxel.val[6];
      workingVoxel = SetVoxelValuesByFourthDiagonal(voxel);
      if (cubeIndex == 0xa1)
        indexOffset = 115;
      else
        indexOffset = 124;
      break;
    // Front Bottom Left
    case 0x1a:
    case 0xe5:
      face1.val[0] = voxel.val[1];
      face1.val[1] = voxel.val[2];
      face1.val[2] = voxel.val[3];
      face1.val[3] = voxel.val[0];
      face2.val[0] = voxel.val[1];
      face2.val[1] = voxel.val[5];
      face2.val[2] = voxel.val[4];
      face2.val[3] = voxel.val[0];
      face3.val[0] = voxel.val[3];
      face3.val[1] = voxel.val[0];
      face3.val[2] = voxel.val[4];
      face3.val[3] = voxel.val[7];
      workingVoxel = SetVoxelValuesByFirstDiagonal(voxel);
      if (cubeIndex == 0x1a)
        indexOffset = 133;
      else
        indexOffset = 142;
      break;

    default:
      return 0;
      break;
  }

  int faceAmbiguityResolved1 = ResolveFaceAmbiguity(face1);
  int faceAmbiguityResolved2 = ResolveFaceAmbiguity(face2);
  int faceAmbiguityResolved3 = ResolveFaceAmbiguity(face2);

  if (faceAmbiguityResolved1 == -1 || faceAmbiguityResolved2 == -1 ||
      faceAmbiguityResolved3 == -1)
    faceAmbiguityResolved1 = faceAmbiguityResolved2 = faceAmbiguityResolved3 =
        1;

  indexOffset -= faceAmbiguityResolved1 * 4 + faceAmbiguityResolved2 * 2 +
                 faceAmbiguityResolved3;

  if (indexOffset % 9 == 7) {
    AMBIGUITYRESOLVERETURN ambiguityResolved =
        ResolveInVoxelAmbiguity(workingVoxel);
    indexOffset += ambiguityResolved.connected;
  }

  return CreateSurfaceInVoxel(voxel, triangles, triangleLabels, cache,
                              edgeTableCase7[indexOffset],
                              triTableCase7[indexOffset]);
}

/**
 * @brief Decides which of the 3 (+1) subcases of case 10 is present and
 *        creates the corresponding surface.
 *
 * If the positive and negative nodes of the ambiguous face multiplied together
 * have the exact same value the face ambiguity is not resolvable and this
 * method defaults to subcase 10.1.1.
 * TODO: While this is unlikely to occur in real data it should still be fixed.
 *
 * @param voxel           - The voxel to create a surface of
 * @param triangles       - Array containing 9 TRIANGLEs. Contains the correct
 *                          triangles after this method returns.
 * @param triangleLabels  - Array containing 9 TRIANGLELABELs. Contains which
 *                          side of the TRIANGLE is facing outwards, which
 *                          inwards.
 * @param cache           - A cache to make sure every vertex exists only once.
 * @param cubeindex       - The index into the edge and tri tables.
 *
 * @return                - The number of creted TRIANGLEs. Use this to
 *                          determine how many entries of the triangles
 *                          parameter to consider.
 */
static int ResolveCase10(const GRIDCELL& voxel, int cubeIndex,
                         MarchingCubes::TRIANGLE* triangles,
                         TRIANGLELABEL* triangleLabels, VertexCache& cache) {
  GRIDCELL face1;
  GRIDCELL face2;
  GRIDCELL workingVoxel;
  int indexOffset = 0;

  switch (cubeIndex) {
    // Bottom Left + Top Right
    case 0x55:
      //    return 0;
      face1.val[0] = voxel.val[0];
      face1.val[1] = voxel.val[1];
      face1.val[2] = voxel.val[2];
      face1.val[3] = voxel.val[3];
      face2.val[0] = voxel.val[4];
      face2.val[1] = voxel.val[5];
      face2.val[2] = voxel.val[6];
      face2.val[3] = voxel.val[7];
      indexOffset = 0;
      break;

    // Bottom Front + Top Back
    case 0xc3:
      //    return 0;
      face1.val[0] = voxel.val[1];
      face1.val[1] = voxel.val[5];
      face1.val[2] = voxel.val[6];
      face1.val[3] = voxel.val[2];
      face2.val[0] = voxel.val[0];
      face2.val[1] = voxel.val[4];
      face2.val[2] = voxel.val[7];
      face2.val[3] = voxel.val[3];
      indexOffset = 4;
      break;

    // Front Right + Back Left
    case 0x96:
      //    return 0;
      face1.val[0] = voxel.val[1];
      face1.val[1] = voxel.val[5];
      face1.val[2] = voxel.val[4];
      face1.val[3] = voxel.val[0];
      face2.val[0] = voxel.val[2];
      face2.val[1] = voxel.val[6];
      face2.val[2] = voxel.val[7];
      face2.val[3] = voxel.val[3];
      indexOffset = 8;
      break;

      // Bottom Right + Top Left
    case 0xaa:
      //  return 0;
      face1.val[0] = voxel.val[1];
      face1.val[1] = voxel.val[2];
      face1.val[2] = voxel.val[3];
      face1.val[3] = voxel.val[4];
      face2.val[0] = voxel.val[5];
      face2.val[1] = voxel.val[6];
      face2.val[2] = voxel.val[7];
      face2.val[3] = voxel.val[4];
      indexOffset = 12;
      break;

    // Bottom Back + Top Front
    case 0x3c:
      //    return 0;
      face1.val[0] = voxel.val[2];
      face1.val[1] = voxel.val[1];
      face1.val[2] = voxel.val[5];
      face1.val[3] = voxel.val[6];
      face2.val[0] = voxel.val[3];
      face2.val[1] = voxel.val[0];
      face2.val[2] = voxel.val[4];
      face2.val[3] = voxel.val[7];
      indexOffset = 16;
      break;

    // Front Left + Back Right
    case 0x69:
      //    return 0;
      face1.val[0] = voxel.val[0];
      face1.val[1] = voxel.val[1];
      face1.val[2] = voxel.val[5];
      face1.val[3] = voxel.val[4];
      face2.val[0] = voxel.val[3];
      face2.val[1] = voxel.val[2];
      face2.val[2] = voxel.val[6];
      face2.val[3] = voxel.val[7];
      indexOffset = 20;
      break;

    default:
      return 0;
      break;
  }  // switch

  int face1Resolved = ResolveFaceAmbiguity(face1);
  int face2Resolved = ResolveFaceAmbiguity(face2);

  if (face1Resolved != -1 && face2Resolved != -1)  // 10.1.1 as a default
  {
    // 10.1.1 or 10.1.2
    if (face1Resolved + face2Resolved == 2 ||
        face1Resolved + face2Resolved ==
            0) /* <- This line makes no sense but produces seemingly correct
                  results. */
    {
      AMBIGUITYRESOLVERETURN ambiguityResolved =
          ResolveInVoxelAmbiguity(workingVoxel);
      if (ambiguityResolved.connected) indexOffset += 1;
    } else if (face1Resolved == 1)  // 10.2
      indexOffset += 3;
    else /*if(face2Resolved == 1)*/  // 10.2
      indexOffset += 2;
    //    else // 10.1.1 or 10.1.2 /* <- This should be the correct
    //    implementation but apperantly not. */
    //    {
    //      indexOffset = (indexOffset + 12) % 24;
    //      AMBIGUITYRESOLVERETURN ambiguityResolved =
    //          ResolveInVoxelAmbiguity(workingVoxel);
    //      if(ambiguityResolved.connected)
    //        indexOffset += 1;
    //    }
  }

  return CreateSurfaceInVoxel(voxel, triangles, triangleLabels, cache,
                              edgeTableCase10[indexOffset],
                              triTableCase10[indexOffset]);
}

/**
 * @brief Extracts the surface which is contained in the voxel.
 *
 * Determines which Marching Cubes main case is present in the voxel. If the
 * main case is ambiguous (acoording to: Marching Cubes 33 by E.V. Chernyaev)
 * resolves this ambiguity. After that the surface contained within the voxel
 * is created and returned.
 *
 * @param voxel           - The voxel to create a surface of
 * @param isolevel        - The isolevel for inside/outside seperation
 * @param triangles       - Array containing TRIANGLEs. Contains the correct
 *                          triangles after this method returns.
 * @param triangleLabels  - Array containing TRIANGLELABELs. Contains which
 *                          side of the TRIANGLE is facing outwards, which
 *                          inwards after this method returns.
 * @param cache           - A cache to make sure every vertex exists only once.
 * @return                - The number of creted TRIANGLEs. Use this to
 *                          determine how many entries of the triangles
 *                          parameter to consider.
 */
static int Polygonise(const GRIDCELL& voxel, double isolevel, int cubeIndex,
                      MarchingCubes::TRIANGLE* triangles,
                      TRIANGLELABEL* triangleLabels, VertexCache& cache) {
  GRIDCELL workingVoxel = voxel;
  for (int i = 7; i >= 0; i--) workingVoxel.val[i] = voxel.val[i] - isolevel;

  /* Determines the main case the voxel belongs to. */
  switch (caseTable[cubeIndex]) /* Fall throughs are intended */
  {
    /* Cases without ambiguity */
    case -1:
    case -2:
    case -5:
    case 1:
    case 2:
    case 5:
    case 8:
    case 9:
    case 11:
    case 14:
      return CreateSurfaceInVoxel(workingVoxel, triangles, triangleLabels,
                                  cache, edgeTable[cubeIndex],
                                  triTable[cubeIndex]);
      break;

    /* Cases with ambiguity */
    case -3:
      return ResolveCase3(workingVoxel, cubeIndex, triangles, triangleLabels,
                          cache);
      break;
    case -4:
      return ResolveCase4(workingVoxel, cubeIndex, triangles, triangleLabels,
                          cache);
      break;
    case -6:
      return ResolveCase6(workingVoxel, cubeIndex, triangles, triangleLabels,
                          cache);
      break;
    case -7:
      return ResolveCase7(workingVoxel, cubeIndex, triangles, triangleLabels,
                          cache);
      break;

    case 3:
      return ResolveCase3(workingVoxel, cubeIndex, triangles, triangleLabels,
                          cache);
      break;
    case 4:
      return ResolveCase4(workingVoxel, cubeIndex, triangles, triangleLabels,
                          cache);
      break;
    case 6:
      return ResolveCase6(workingVoxel, cubeIndex, triangles, triangleLabels,
                          cache);
      break;
    case 7:
      return ResolveCase7(workingVoxel, cubeIndex, triangles, triangleLabels,
                          cache);
      break;
    case 10:
      return ResolveCase10(workingVoxel, cubeIndex, triangles, triangleLabels,
                           cache);
      break;
    case 12:
    case 13:
      // Temporary until subcase identifications are implemented
      return CreateSurfaceInVoxel(workingVoxel, triangles, triangleLabels,
                                  cache, edgeTable[cubeIndex],
                                  triTable[cubeIndex]);
      break;

    default:
      return 0;
      break;
  }
}

MarchingCubes::MarchingCubes() {}

MarchingCubes::~MarchingCubes() {
  delete vertices;
  delete triangles;
}

/**
 * @brief Takes a volume and extracts the by an isovalue implicitly contained
 *        surface.
 *
 * @param inputVolume - The volume from which to extrat the surface
 * @param dimensions  - The number of voxels in x, y, z direction
 * @param origin      - The 3D position of the volumes origin
 * @param spacing     - The distance between voxels in x, y, z direction
 * @param isovalue    - The threshold for which datapoints lie inside and which
 *                      outside the surface.
 */
void MarchingCubes::extract(vx::Array3<const float>& inputVolume,
                            const vx::TupleVector<quint64, 3>& dimensions,
                            const QVector3D& origin, const QVector3D& spacing,
                            float isovalue) {
  static const int offsets[][3] = {
      {0, 0, 1}, {1, 0, 1}, {1, 0, 0}, {0, 0, 0},
      {0, 1, 1}, {1, 1, 1}, {1, 1, 0}, {0, 1, 0},
  };

  MarchingCubes::TRIANGLE triangles[9];
  /* These triangleLabels serve no purpose currently and are simply here to
   * make it easier to reimplement the functionality seen in MarchingCubes.cpp.
   */
  TRIANGLELABEL triangleLabels[9];
  GRIDCELL cell;

  VertexCache cache(std::get<0>(dimensions), std::get<1>(dimensions));

  for (ptrdiff_t z = 0; z < (ptrdiff_t)std::get<2>(dimensions) - 1; z++) {
    cache.nextPlane();

    for (ptrdiff_t y = 0; y < (ptrdiff_t)std::get<1>(dimensions) - 1; y++) {
      for (ptrdiff_t x = 0; x < (ptrdiff_t)std::get<0>(dimensions) - 1; x++) {
        int cubeIndex = 0;
        for (int i = 0; i < 8; i++) {
          if (inputVolume(x + offsets[i][0], y + offsets[i][1],
                          z + offsets[i][2]) < isovalue)
            cubeIndex |= 1 << i;
        }
        if (cubeIndex == 0 || cubeIndex == 255) continue;

        /* Get the 3D position and value of every corner */
        for (int i = 0; i < 8; i++) {
          /* Get the 3D position of a corner */
          QVector3D pos =
              origin + QVector3D((x + offsets[i][0] - 0.5f) * spacing.x(),
                                 (y + offsets[i][1] - 0.5f) * spacing.y(),
                                 (z + offsets[i][2] - 0.5f) * spacing.z());

          cell.pos[i] = pos;
          /* Get the value of a corner */
          cell.val[i] = inputVolume(x + offsets[i][0], y + offsets[i][1],
                                    z + offsets[i][2]);
        }
        cell.x = x;
        cell.y = y;
        cell.z = z;
        /* Extract the surface of this voxel */
        int count = Polygonise(cell, isovalue, cubeIndex, triangles,
                               triangleLabels, cache);
        /* The voxel is empty */
        if (count == 0) continue;

        /* The surface is not empty */
        for (int i = 0; i < count; i++) {
          AddTriangle(triangles[i].indices[0], triangles[i].indices[1],
                      triangles[i].indices[2]);
        }
      }
    }
  }
}
